(include "math")

(define (second x) (car (cdr x)))

(define (distance u v) (magnitude (v- v u)))

(define (naive-euler w)
 (let* ((x-initial '(0.0 8.0))
	(xdot-initial '(0.75 0.0))
	(delta-t 1e-1)
	(charges (list (list 10.0 (- 10.0 w)) (list 10.0 0.0)))
	(p (lambda (x)
	    ((reduce + 0.0)
	     (map (lambda (c) (/ 1.0 (distance x c))) charges))))
	(del-p (gradient-using-j* p)))
  (letrec ((loop (lambda (x xdot)
		  (let* ((xddot (k*v -1.0 (del-p (write x))))
			 (x-new (v+ x (k*v delta-t xdot))))
		   (if (positive? (second x-new))
		       (loop x-new (v+ xdot (k*v delta-t xddot)))
		       (let* ((delta-t-f (/ (- (second x-new) (second x))
					    (second xdot)))
			      (x-t-f (v+ x (k*v delta-t-f xdot))))
			(sqr (first x-t-f))))))))
   (loop x-initial xdot-initial))))

(define (argmin-using-textbook-newtons-method f x)
 (let ((error-tolerance 1e-1) (f-j*-j* (j* (j* f))))
  (letrec ((loop
	    (lambda (x i)
	     (let* ((result
		     (f-j*-j* (bundle (bundle (write x) (perturb 1))
				      (perturb (bundle 1 (perturb 0))))))
		    (df-dx (primal (unperturb (tangent result)))))
	      (if (< (abs df-dx) error-tolerance)
		  x
		  (loop
		   (- x
		      (/ df-dx
			 (unperturb (tangent (unperturb (tangent result))))))
		   (+ i 1)))))))
   (loop x 0))))

(let ((w0 0.0)) (argmin-using-textbook-newtons-method naive-euler w0))
