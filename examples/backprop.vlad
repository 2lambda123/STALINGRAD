;;; -*- scheme -*-
;;; CVS version control block - do not edit manually
;;;  $RCSfile$
;;;  $Revision$
;;;  $Date$
;;;  $Source$

(include "math")

;;; Representation for weights:
;;;  list with one element for each layer following the input;
;;;  each such list has one element for each unit in that layer;
;;;  which consists of a bias, followed by the weights for each
;;;  unit in the previous layer.

(define ((sum-activities activities) (cons bias ws))
  ((reduce + bias)
   (map2 * ws activities)))

(define (sum-layer activities ws-layer)
  (map (sum-activities activities) ws-layer))

(define ((forward-pass ws-layers) in)
  (if (null? ws-layers)
      in
      ((forward-pass (cdr ws-layers))
       (map sigmoid (sum-layer in (car ws-layers))))))

(define (sigmoid x) (/ 1 (+ 1 (exp (- 0 x)))))

(define (xor-ws)
  (map-real '(((-1 2 2) (-6 4 4)) ((-5 10 -10)))))

(define (xor-data)
  '(((0 0) (0))
    ((0 1) (1))
    ((1 0) (1))
    ((1 1) (0))))

(define (map-real x)
  (cond ((real? x) (real x))
	((pair? x) (cons (map-real (car x))
			 (map-real (cdr x))))
	(else x)))

(define (test-on-dataset ws-layers dataset)
  (map (forward-pass ws-layers)
       (map car dataset)))

(define (test-xor)
  (test-on-dataset (xor-ws) (xor-data)))

(define ((error-on-dataset dataset) ws-layers)
  ((reduce + 0)
   (map (lambda ((list in target))
	  (* 0.5 (magnitude-squared (v- ((forward-pass ws-layers) in) target))))
	dataset)))

;;; test case, zero-dimensional-input one-layer backprop

(define (forward-0d w)
  ((forward-pass (list (list (list w)))) '()))

;;; Should be: (0.5)

; (forward-0d 0)

(define (error-0d w)
  ((error-on-dataset '((() (0.8))))
   (list (list (list w)))))

; (error-0d 0)

; ((derivative-using-j* error-0d) 0)

; ((derivative-using-*j error-0d) 0)

;;; test xor

;;; Should be:
;;;  ((0.08824035437794886)
;;;   (0.7537208761298554)
;;;   (0.7537208761298554)
;;;   (0.01362366627163038))

; (test-xor)

;;; Should be:
;;;  0.06463938906595941

; ((error-on-dataset (xor-data)) (xor-ws))

; ((gradient (error-on-dataset (xor-data))) (xor-ws))

;;; Scaled structure subtraction

(define (s-k* x k y)
  (cond ((real? x) (- x (* k y)))
	((pair? x) (cons (s-k* (car x) k (car y))
			 (s-k* (cdr x) k (cdr y))))
	(else x)))

;;; Vanilla gradient optimization.
;;; Gradient minimize f starting at w0 for n iterations via
;;; w(t+1) = w(t) - eta * grad_w f.
;;; Returns list of all w's.

(define (vanilla f w0 n eta)
  (if (zero? n)
      (list w0)
      (cons w0
	    (vanilla f
		     (s-k* w0 eta ((gradient f) w0))
		     (- n 1)
		     eta))))

;;; Test case: maximize cos 

(vanilla (lambda (x) (- 0 (cos x)))
	 0.5
	 50
	 0.3)

(map cos
     (vanilla (lambda (x) (- 0 (cos x)))
	      0.5
	      50
	      0.3))

;;; Correct Daniel Websters's spelling error

(define (sensitise x) (sensitize x))
(define (unsensitise x) (unsensitize x))

;;; double-vanilla returns a list of successive values of w and f(w)

(define (double-vanilla f w0 n eta)
  (let (((cons fw f-reverse) ((*j f) (*j w0))))
    (cons (list w0 (*j-inverse fw))
	  (if (zero? n)
	      '()
	      (double-vanilla f
			      (s-k* w0 eta
				    (cdr (unsensitise
					  (f-reverse
					   (sensitise 1)))))
			      (- n 1)
			      eta)))))

(double-vanilla (lambda (x) (- 0 (cos x)))
		0.5
		50
		0.3)

;;; Local Variables:
;;; compile-command: "SCMAXHEAP=1000 ../bin/stalingrad-i686 backprop"
;;; End:
