(letrec ((plus
	  ;; plus is used on the results of backpropagators. The input will
	  ;; always be a pair of same-shape trees. Each tree will only contain
	  ;; nulls, numbers, pairs, and procedures. #F is used to indicate a
	  ;; generic zero.
	  (lambda (x1 x2)
	   (cond ((boolean? x1) x2)
		 ((boolean? x2) x1)
		 ((null? x1) ())
		 ((real? x1) (+ x1 x2))
		 ((pair? x1)
		  (cons (plus (car x1) (car x2)) (plus (cdr x1) (cdr x2))))
		 ;; procedure
		 (else (lambda (y) (plus (x1 y) (x2 y)))))))
	 (identity (lambda (x) x))
	 (j*
	  (lambda (x)
	   (cond
	    ((null? x) (cons x ()))
	    ((boolean? x) (cons x ()))
	    ((real? x) (cons x 0))
	    ((pair? x) (cons (j* (car x)) (j* (cdr x))))
	    ((eq? x +)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (+ x1 x2) (+ x1-acute x2-acute))))
	    ((eq? x -)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (- x1 x2) (- x1-acute x2-acute))))
	    ((eq? x *)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (* x1 x2) (+ (* x2 x1-acute) (* x1 x2-acute)))))
	    ((eq? x /)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (/ x1 x2)
		    (/ (- (* x2 x1-acute) (* x1 x2-acute)) (* x2 x2)))))
	    ((eq? x sqrt)
	     (lambda (x x-acute) (cons (sqrt x) (/ x-acute (* 2 (sqrt x))))))
	    ((eq? x exp)
	     (lambda (x x-acute) (cons (exp x) (* (exp x) x-acute))))
	    ((eq? x log) (lambda (x x-acute) (cons (log x) (/ x-acute x))))
	    ((eq? x sin)
	     (lambda (x x-acute) (cons (sin x) (* (cos x) x-acute))))
	    ((eq? x cos)
	     (lambda (x x-acute) (cons (cos x) (- 0 (* (sin x) x-acute)))))
	    ((eq? x atan)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (atan x2 x1)
		    (/ (- (* x1 x2-acute) (* x2 x1-acute))
		       (+ (* x1 x1) (* x2 x2))))))
	    ((eq? x =)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (= x1 x2) ())))
	    ((eq? x <)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (< x1 x2) ())))
	    ((eq? x >)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (> x1 x2) ())))
	    ((eq? x <=)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (<= x1 x2) ())))
	    ((eq? x >=)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (>= x1 x2) ())))
	    ((eq? x zero?) (lambda (x x-acute) (cons (zero? x) ())))
	    ((eq? x positive?) (lambda (x x-acute) (cons (positive? x) ())))
	    ((eq? x negative?) (lambda (x x-acute) (cons (negative? x) ())))
	    ((eq? x null?)
	     (lambda (x) (cons (if (pair? x) (null? (car x)) #f) ())))
	    ((eq? x boolean?)
	     (lambda (x) (cons (if (pair? x) (boolean? (car x)) #f) ())))
	    ((eq? x real?)
	     (lambda (x) (cons (if (pair? x) (real? (car x)) #f) ())))
	    ((eq? x pair?)
	     (lambda (x)
	      (cons (if (pair? x)
			(cond ((null? (car x)) #f)
			      ((boolean? (car x)) #f)
			      ((real? (car x)) #f)
			      (else #t))
			#f)
		    ())))
	    ((eq? x procedure?) (lambda (x) (cons (procedure? x) ())))
	    ((eq? x car) car)
	    ((eq? x cdr) cdr)
	    ((eq? x cons-procedure) cons-procedure)
	    ((eq? x if-procedure)
	     (lambda ((cons x1 x1-acute) x2 x3) (if-procedure x1 x2 x3)))
	    ((eq? x eq?)
	     (lambda (x1 x2)
	      (cons (if (procedure? x1)
			(if (procedure? x2) (eq? x1 x2) #f)
			(if (procedure? x2) #f (eq? (car x1) (car x2))))
		    ())))
	    ;; needs work: not sure if this is correct
	    ((eq? x map-closure) map-closure)
	    ((eq? x write) write)
	    ((eq? x j*) j*)
	    ;; needs work: not sure if this is correct
	    ((eq? x *j) *j)
	    (else (map-closure j* x)))))
	 (*j
	  (lambda (x)
	   (cond
	    ;; needs work: to check that y-grave is null
	    ((null? x) (cons x (lambda (y-grave) #f)))
	    ;; needs work: to check that y-grave is null
	    ((boolean? x) (cons x (lambda (y-grave) #f)))
	    ;; needs work: to check that y-grave is real
	    ((real? x) (cons x (lambda (y-grave) #f)))
	    ((pair? x) (cons (*j (car x)) (*j (cdr x))))
	    ((eq? x +)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      (cons (+ x1 x2)
		    (lambda (y-grave)
		     (plus (x1-tilde y-grave) (x2-tilde y-grave))))))
	    ((eq? x -)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      (cons (- x1 x2)
		    (lambda (y-grave)
		     (plus (x1-tilde y-grave) (x2-tilde (- 0 y-grave)))))))
	    ((eq? x *)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      (cons
	       (* x1 x2)
	       (lambda (y-grave)
		(plus (x1-tilde (* x2 y-grave)) (x2-tilde (* x1 y-grave)))))))
	    ((eq? x /)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      (cons (/ x1 x2)
		    (lambda (y-grave)
		     (plus (x1-tilde (/ y-grave x2))
			   (x2-tilde (- 0 (/ (* x1 y-grave) (* x2 x2)))))))))
	    ((eq? x sqrt)
	     (lambda (x x-tilde)
	      (cons (sqrt x)
		    (lambda (y-grave) (x-tilde (/ y-grave (* 2 (sqrt x))))))))
	    ((eq? x exp)
	     (lambda (x x-tilde)
	      (cons (exp x) (lambda (y-grave) (x-tilde (* (exp x) y-grave))))))
	    ((eq? x log)
	     (lambda (x x-tilde)
	      (cons (log x) (lambda (y-grave) (x-tilde (/ y-grave x))))))
	    ((eq? x sin)
	     (lambda (x x-tilde)
	      (cons (sin x) (lambda (y-grave) (x-tilde (* (cos x) y-grave))))))
	    ((eq? x cos)
	     (lambda (x x-tilde)
	      (cons (cos x)
		    (lambda (y-grave) (x-tilde (- 0 (* (sin x) y-grave)))))))
	    ((eq? x atan)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      (cons
	       (atan x2 x1)
	       (lambda (y-grave)
		(plus
		 (x1-tilde (- 0 (/ (* x2 y-grave) (+ (* x1 x1) (* x2 x2)))))
		 (x2-tilde (/ (* x1 y-grave) (+ (* x1 x1) (* x2 x2)))))))))
	    ((eq? x =)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      ;; needs work: to check that y-grave is null
	      (cons (= x1 x2) (lambda (y-grave) #f))))
	    ((eq? x <)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      ;; needs work: to check that y-grave is null
	      (cons (< x1 x2) (lambda (y-grave) #f))))
	    ((eq? x >)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      ;; needs work: to check that y-grave is null
	      (cons (> x1 x2) (lambda (y-grave) #f))))
	    ((eq? x <=)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      ;; needs work: to check that y-grave is null
	      (cons (<= x1 x2) (lambda (y-grave) #f))))
	    ((eq? x >=)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      ;; needs work: to check that y-grave is null
	      (cons (>= x1 x2) (lambda (y-grave) #f))))
	    ((eq? x zero?)
	     ;; needs work: to check that y-grave is null
	     (lambda (x x-tilde) (cons (zero? x) (lambda (y-grave) #f))))
	    ((eq? x positive?)
	     ;; needs work: to check that y-grave is null
	     (lambda (x x-tilde) (cons (positive? x) (lambda (y-grave) #f))))
	    ((eq? x negative?)
	     ;; needs work: to check that y-grave is null
	     (lambda (x x-tilde) (cons (negative? x) (lambda (y-grave) #f))))
	    ((eq? x null?)
	     (lambda (x)
	      ;; needs work: to check that y-grave is null
	      (cons (if (pair? x) (null? (car x)) #f) (lambda (y-grave) #f))))
	    ((eq? x boolean?)
	     (lambda (x)
	      (cons (if (pair? x) (boolean? (car x)) #f)
		    ;; needs work: to check that y-grave is null
		    (lambda (y-grave) #f))))
	    ((eq? x real?)
	     (lambda (x)
	      ;; needs work: to check that y-grave is null
	      (cons (if (pair? x) (real? (car x)) #f) (lambda (y-grave) #f))))
	    ((eq? x pair?)
	     (lambda (x)
	      (cons (if (pair? x)
			(cond ((null? (car x)) #f)
			      ((boolean? (car x)) #f)
			      ((real? (car x)) #f)
			      (else #t))
			#f)
		    ;; needs work: to check that y-grave is null
		    (lambda (y-grave) #f))))
	    ((eq? x procedure?)
	     ;; needs work: to check that y-grave is null
	     (lambda (x) (cons (procedure? x) (lambda (y-grave) #f))))
	    ((eq? x car) car)
	    ((eq? x cdr) cdr)
	    ((eq? x cons-procedure) cons-procedure)
	    ((eq? x if-procedure)
	     (lambda ((cons x1 x1-tilde) x2 x3) (if-procedure x1 x2 x3)))
	    ((eq? x eq?)
	     (lambda (x1 x2)
	      (cons (if (procedure? x1)
			(if (procedure? x2) (eq? x1 x2) #f)
			(if (procedure? x2) #f (eq? (car x1) (car x2))))
		    ;; needs work: to check that y-grave is null
		    (lambda (y-grave) #f))))
	    ;; needs work: not sure if this is correct
	    ((eq? x map-closure) map-closure)
	    ((eq? x write) write)
	    ;; needs work: not sure if this is correct
	    ((eq? x j*) j*)
	    ((eq? x *j) *j)
	    (else (map-closure *j x)))))
	 (derivative
	  ;;(lambda (f) (lambda (x) (cdr ((j* f) x 1))))
	  (lambda (f) (lambda (x) ((cdr ((*j f) x identity)) 1))))
	 (root (lambda (f)
		(lambda (x)
		 (let* ((x-prime (- x (/ (f x) ((derivative f) x)))))
		  (if (= x x-prime) x (root f x-prime)))))))
 ;;((derivative (derivative (lambda (x) (+ x x)))) 4)
 ;;((derivative (derivative sqrt)) 4)
 ;;((derivative (derivative (derivative sqrt))) 4)
 ;;((derivative (lambda (x) (car (cons x x)))) 4)
 ((derivative (derivative (lambda (x) (car (cons x x))))) 4))
