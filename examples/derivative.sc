(letrec ((plus
	  ;; plus is used on the results of backpropagators. The input will
	  ;; always be a pair of same-shape trees. Each tree will only contain
	  ;; nulls, numbers, pairs, and procedures. #F is used to indicate a
	  ;; generic zero.
	  (lambda (x1 x2)
	   (cond ((boolean? x1) x2)
		 ((boolean? x2) x1)
		 ((null? x1) ())
		 ((real? x1) (+ x1 x2))
		 ((pair? x1)
		  (cons (plus (car x1) (car x2)) (plus (cdr x1) (cdr x2))))
		 ;; procedure
		 (else (lambda (y) (plus (x1 y) (x2 y)))))))
	 (identity (lambda (x) x))
	 (not (lambda (x) (if x #f #t)))
	 (abs (lambda (x) (if (negative? x) (- 0 x) x)))
	 (sqr (lambda (x) (* x x)))
	 (j*
	  (lambda (x)
	   (cond
	    ((null? x) (cons x ()))
	    ((boolean? x) (cons x ()))
	    ((real? x) (cons x 0))
	    ((pair? x) (cons (j* (car x)) (j* (cdr x))))
	    ((eq? x +)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (+ x1 x2) (+ x1-acute x2-acute))))
	    ((eq? x -)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (- x1 x2) (- x1-acute x2-acute))))
	    ((eq? x *)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (* x1 x2) (+ (* x2 x1-acute) (* x1 x2-acute)))))
	    ((eq? x /)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (/ x1 x2)
		    (/ (- (* x2 x1-acute) (* x1 x2-acute)) (* x2 x2)))))
	    ((eq? x sqrt)
	     (lambda (x x-acute) (cons (sqrt x) (/ x-acute (* 2 (sqrt x))))))
	    ((eq? x exp)
	     (lambda (x x-acute) (cons (exp x) (* (exp x) x-acute))))
	    ((eq? x log) (lambda (x x-acute) (cons (log x) (/ x-acute x))))
	    ((eq? x sin)
	     (lambda (x x-acute) (cons (sin x) (* (cos x) x-acute))))
	    ((eq? x cos)
	     (lambda (x x-acute) (cons (cos x) (- 0 (* (sin x) x-acute)))))
	    ((eq? x atan)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      (cons (atan x2 x1)
		    (/ (- (* x1 x2-acute) (* x2 x1-acute))
		       (+ (* x1 x1) (* x2 x2))))))
	    ((eq? x =)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      ;; needs work: to check that x1-acute and x2-acute are real
	      (cons (= x1 x2) ())))
	    ((eq? x <)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      ;; needs work: to check that x1-acute and x2-acute are real
	      (cons (< x1 x2) ())))
	    ((eq? x >)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      ;; needs work: to check that x1-acute and x2-acute are real
	      (cons (> x1 x2) ())))
	    ((eq? x <=)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      ;; needs work: to check that x1-acute and x2-acute are real
	      (cons (<= x1 x2) ())))
	    ((eq? x >=)
	     (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
	      ;; needs work: to check that x1-acute and x2-acute are real
	      (cons (>= x1 x2) ())))
	    ;; needs work: to check that x-acute is real
	    ((eq? x zero?) (lambda (x x-acute) (cons (zero? x) ())))
	    ;; needs work: to check that x-acute is real
	    ((eq? x positive?) (lambda (x x-acute) (cons (positive? x) ())))
	    ;; needs work: to check that x-acute is real
	    ((eq? x negative?) (lambda (x x-acute) (cons (negative? x) ())))
	    ((eq? x null?)
	     (lambda (x) (cons (if (pair? x) (null? (car x)) #f) ())))
	    ((eq? x boolean?)
	     (lambda (x) (cons (if (pair? x) (boolean? (car x)) #f) ())))
	    ((eq? x real?)
	     (lambda (x) (cons (if (pair? x) (real? (car x)) #f) ())))
	    ((eq? x pair?)
	     (lambda (x)
	      (cons (if (pair? x)
			(cond ((null? (car x)) #f)
			      ((boolean? (car x)) #f)
			      ((real? (car x)) #f)
			      (else #t))
			#f)
		    ())))
	    ((eq? x procedure?) (lambda (x) (cons (procedure? x) ())))
	    ((eq? x car) car)
	    ((eq? x cdr) cdr)
	    ((eq? x cons-procedure) cons-procedure)
	    ((eq? x if-procedure)
	     (lambda ((cons x1 x1-acute) x2 x3) (if-procedure x1 x2 x3)))
	    ((eq? x eq?)
	     (lambda (x1 x2)
	      (cons (if (procedure? x1)
			(if (procedure? x2) (eq? x1 x2) #f)
			(if (procedure? x2) #f (eq? (car x1) (car x2))))
		    ())))
	    ;; needs work: not sure if this is correct
	    ((eq? x map-closure) map-closure)
	    ((eq? x write) write)
	    ((eq? x j*) j*)
	    ;; needs work: not sure if this is correct
	    ((eq? x *j) *j)
	    (else (map-closure j* x)))))
	 (*j
	  (lambda (x)
	   (cond
	    ;; needs work: to check that y-grave is null
	    ((null? x) (cons x (lambda (y-grave) #f)))
	    ;; needs work: to check that y-grave is null
	    ((boolean? x) (cons x (lambda (y-grave) #f)))
	    ;; needs work: to check that y-grave is real
	    ((real? x) (cons x (lambda (y-grave) #f)))
	    ((pair? x) (cons (*j (car x)) (*j (cdr x))))
	    ((eq? x +)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      (cons (+ x1 x2)
		    (lambda (y-grave)
		     (plus (x1-tilde y-grave) (x2-tilde y-grave))))))
	    ((eq? x -)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      (cons (- x1 x2)
		    (lambda (y-grave)
		     (plus (x1-tilde y-grave) (x2-tilde (- 0 y-grave)))))))
	    ((eq? x *)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      (cons
	       (* x1 x2)
	       (lambda (y-grave)
		(plus (x1-tilde (* x2 y-grave)) (x2-tilde (* x1 y-grave)))))))
	    ((eq? x /)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      (cons (/ x1 x2)
		    (lambda (y-grave)
		     (plus (x1-tilde (/ y-grave x2))
			   (x2-tilde (- 0 (/ (* x1 y-grave) (* x2 x2)))))))))
	    ((eq? x sqrt)
	     (lambda (x x-tilde)
	      (cons (sqrt x)
		    (lambda (y-grave) (x-tilde (/ y-grave (* 2 (sqrt x))))))))
	    ((eq? x exp)
	     (lambda (x x-tilde)
	      (cons (exp x) (lambda (y-grave) (x-tilde (* (exp x) y-grave))))))
	    ((eq? x log)
	     (lambda (x x-tilde)
	      (cons (log x) (lambda (y-grave) (x-tilde (/ y-grave x))))))
	    ((eq? x sin)
	     (lambda (x x-tilde)
	      (cons (sin x) (lambda (y-grave) (x-tilde (* (cos x) y-grave))))))
	    ((eq? x cos)
	     (lambda (x x-tilde)
	      (cons (cos x)
		    (lambda (y-grave) (x-tilde (- 0 (* (sin x) y-grave)))))))
	    ((eq? x atan)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      (cons
	       (atan x2 x1)
	       (lambda (y-grave)
		(plus
		 (x1-tilde (- 0 (/ (* x2 y-grave) (+ (* x1 x1) (* x2 x2)))))
		 (x2-tilde (/ (* x1 y-grave) (+ (* x1 x1) (* x2 x2)))))))))
	    ((eq? x =)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      ;; needs work: to check that y-grave is null
	      (cons (= x1 x2) (lambda (y-grave) #f))))
	    ((eq? x <)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      ;; needs work: to check that y-grave is null
	      (cons (< x1 x2) (lambda (y-grave) #f))))
	    ((eq? x >)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      ;; needs work: to check that y-grave is null
	      (cons (> x1 x2) (lambda (y-grave) #f))))
	    ((eq? x <=)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      ;; needs work: to check that y-grave is null
	      (cons (<= x1 x2) (lambda (y-grave) #f))))
	    ((eq? x >=)
	     (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
	      ;; needs work: to check that y-grave is null
	      (cons (>= x1 x2) (lambda (y-grave) #f))))
	    ((eq? x zero?)
	     ;; needs work: to check that y-grave is null
	     (lambda (x x-tilde) (cons (zero? x) (lambda (y-grave) #f))))
	    ((eq? x positive?)
	     ;; needs work: to check that y-grave is null
	     (lambda (x x-tilde) (cons (positive? x) (lambda (y-grave) #f))))
	    ((eq? x negative?)
	     ;; needs work: to check that y-grave is null
	     (lambda (x x-tilde) (cons (negative? x) (lambda (y-grave) #f))))
	    ((eq? x null?)
	     (lambda (x)
	      ;; needs work: to check that y-grave is null
	      (cons (if (pair? x) (null? (car x)) #f) (lambda (y-grave) #f))))
	    ((eq? x boolean?)
	     (lambda (x)
	      (cons (if (pair? x) (boolean? (car x)) #f)
		    ;; needs work: to check that y-grave is null
		    (lambda (y-grave) #f))))
	    ((eq? x real?)
	     (lambda (x)
	      ;; needs work: to check that y-grave is null
	      (cons (if (pair? x) (real? (car x)) #f) (lambda (y-grave) #f))))
	    ((eq? x pair?)
	     (lambda (x)
	      (cons (if (pair? x)
			(cond ((null? (car x)) #f)
			      ((boolean? (car x)) #f)
			      ((real? (car x)) #f)
			      (else #t))
			#f)
		    ;; needs work: to check that y-grave is null
		    (lambda (y-grave) #f))))
	    ((eq? x procedure?)
	     ;; needs work: to check that y-grave is null
	     (lambda (x) (cons (procedure? x) (lambda (y-grave) #f))))
	    ((eq? x car) car)
	    ((eq? x cdr) cdr)
	    ((eq? x cons-procedure) cons-procedure)
	    ((eq? x if-procedure)
	     (lambda ((cons x1 x1-tilde) x2 x3) (if-procedure x1 x2 x3)))
	    ((eq? x eq?)
	     (lambda (x1 x2)
	      (cons (if (procedure? x1)
			(if (procedure? x2) (eq? x1 x2) #f)
			(if (procedure? x2) #f (eq? (car x1) (car x2))))
		    ;; needs work: to check that y-grave is null
		    (lambda (y-grave) #f))))
	    ;; needs work: not sure if this is correct
	    ((eq? x map-closure) map-closure)
	    ((eq? x write) write)
	    ;; needs work: not sure if this is correct
	    ((eq? x j*) j*)
	    ((eq? x *j) *j)
	    (else (map-closure *j x)))))
	 (derivative
	  ;;(lambda (f) (lambda (x) (cdr ((j* f) x 1))))
	  (lambda (f) (lambda (x) ((cdr ((*j f) x identity)) 1))))
	 (root (lambda (f x epsilon)
		(let* ((x-prime (- x (/ (f x) ((derivative f) x)))))
		 (if (<= (abs (- x x-prime)) epsilon)
		     x
		     (root f x-prime epsilon)))))
	 ;; needs work: To rule out maxima and inflection points.
	 (argmin (lambda (f x epsilon) (root (derivative f) x epsilon)))
	 ;; An n-dimensional vector with x in position i and zeros elsewhere.
	 (ex (lambda (x i n)
	      (if (zero? n)
		  ()
		  (cons (if (zero? i) x 0) (ex x (- i 1) (- n 1))))))
	 ;; The ith n-dimensional basis vector.
	 (e (lambda (i n) (ex 1 i n)))
	 (first (lambda (x) (car x)))
	 (second (lambda (x) (car (cdr x))))
	 (rest (lambda (x) (cdr x)))
	 (append (lambda (x y)
		  (if (null? x) y (cons (first x) (append (rest x) y)))))
	 (map-n (lambda (f n)
		 (if (zero? n)
		     ()
		     ;; needs work: To use list.
		     (append (map-n f (- n 1)) (cons (f (- n 1)) ())))))
	 ;; The nxn identity matrix.
	 (i (lambda (n) (map-n (lambda (i) (e i n)) n)))
	 (map (lambda (f l)
	       (if (null? l) () (cons (f (first l)) (map f (rest l))))))
	 ;; needs work: To merge with map.
	 (map2 (lambda (f l1 l2)
		(if (null? l1)
		    ()
		    (cons (f (first l1) (first l2))
			  (map2 f (rest l1) (rest l2))))))
	 (forward-conjoint
	  (lambda (primal adjoint)
	   (if (null? primal)
	       (cons () ())
	       (cons (cons (first primal) (first adjoint))
		     (forward-conjoint (rest primal) (rest adjoint))))))
	 (reverse-conjoint
	  (lambda (primal adjoint)
	   (if (null? primal)
	       (cons () (lambda (y-grave) #f))
	       (cons (cons (first primal) (first adjoint))
		     (reverse-conjoint (rest primal) (rest adjoint))))))
	 (reduce (lambda (f i)
		  (lambda (l)
		   (if (null? l)
		       i
		       (f (first l) ((reduce f i) (rest l)))))))
	 (length (lambda (l) (if (null? l) 0 (+ (length (rest l)) 1))))
	 (forward-gradient
	  (lambda (f)
	   (lambda (x)
	    (let* ((n (length x)))
	     (map-n (lambda (i) (cdr ((j* f) (forward-conjoint x (e i n)))))
		    n)))))
	 (reverse-gradient
	  (lambda (f)
	   (lambda (x)
	    (let* ((n (length x)))
	     ((cdr
	       ((*j f)
		(reverse-conjoint
		 x
		 (map-n (lambda (i) (lambda (y-grave) (ex y-grave i n))) n))))
	      1)))))
	 (gradient
	  ;;(lambda (f) (forward-gradient f))
	  (lambda (f) (reverse-gradient f)))
	 (v+ (lambda (u v) (map2 + u v)))
	 (k*v (lambda (k v) (map (lambda (x) (* k x)) v)))
	 (magnitude-squared (lambda (x) ((reduce + 0) (map sqr x))))
	 (magnitude (lambda (x) (sqrt (magnitude-squared x))))
	 (gradient-descent
	  (lambda (f x epsilon)
	   (let* ((g ((gradient f) x)))
	    (if (<= (magnitude g) epsilon)
		x
		(gradient-descent
		 f
		 (v+
		  x
		  (k*v (argmin (lambda (k) (f (v+ x (k*v k g)))) 0 epsilon) g))
		 epsilon))))))
 ;;((derivative (derivative (lambda (x) (+ x x)))) 4)
 ;;((derivative (derivative sqrt)) 4)
 ;;((derivative (derivative (derivative sqrt))) 4)
 ;;((derivative (lambda (x) (car (cons x x)))) 4)
 ;;((derivative (derivative (lambda (x) (car (cons x x))))) 4)
 ;;(root (lambda (x) (- (sqr x) 4)) 5 1e-5)
 ;;(argmin (lambda (x) (sqr (- x 4))) 5 1e-5)
 ;;((gradient magnitude) (cons 3 (cons 4 ())))
 (gradient-descent magnitude-squared (cons 3 (cons 4 ())) 1e-5))
