(define (+-forward x1-forward x2-forward)
 (cons (+ (car x1-forward) (car x2-forward))
       (+ (cdr x1-forward) (cdr x2-forward))))

(define (--forward x1-forward x2-forward)
 (cons (- (car x1-forward) (car x2-forward))
       (- (cdr x1-forward) (cdr x2-forward))))

(define (*-forward x1-forward x2-forward)
 (cons (* (car x1-forward) (car x2-forward))
       (+ (* (car x2-forward) (cdr x1-forward))
	  (* (car x1-forward) (cdr x2-forward)))))

(define (/-forward x1-forward x2-forward)
 (cons (/ (car x1-forward) (car x2-forward))
       (/ (- (* (car x2-forward) (cdr x1-forward))
	     (* (car x1-forward) (cdr x2-forward)))
	  (* (car x2-forward) (car x2-forward)))))

(define (sqrt-forward x-forward)
 (cons (sqrt (car x-forward))
       (/ (cdr x-forward) (* 2 (sqrt (car x-forward))))))

(define (exp-forward x-forward)
 (cons (exp (car x-forward)) (* (exp (car x-forward)) (cdr x-forward))))

(define (log-forward x-forward)
 (cons (log (car x-forward)) (/ (cdr x-forward) (car x-forward))))

(define (sin-forward x-forward)
 (cons (sin (car x-forward)) (* (cos (car x-forward)) (cdr x-forward))))

(define (cos-forward x-forward)
 (cons (cos (car x-forward)) (- 0 (* (sin (car x-forward)) (cdr x-forward)))))

(define (atan-forward x1-forward x2-forward)
 (cons (atan (car x2-forward) (car x1-forward))
       (/ (- (* (car x1-forward) (cdr x2-forward))
	     (* (car x2-forward) (cdr x1-forward)))
	  (+ (* (car x1-forward) (car x1-forward))
	     (* (car x2-forward) (car x2-forward))))))

(define (=-forward x1-forward x2-forward)
 (= (car x1-forward) (car x2-forward)))

(define (<-forward x1-forward x2-forward)
 (< (car x1-forward) (car x2-forward)))

(define (>-forward x1-forward x2-forward)
 (> (car x1-forward) (car x2-forward)))

(define (<=-forward x1-forward x2-forward)
 (<= (car x1-forward) (car x2-forward)))

(define (>=-forward x1-forward x2-forward)
 (>= (car x1-forward) (car x2-forward)))

(define (zero?-forward x-forward) (zero? (car x-forward)))

(define (positive?-forward x-forward) (positive? (car x-forward)))

(define (negative?-forward x-forward) (negative? (car x-forward)))

(define (null?-forward x-forward) (null? x-forward))

(define (boolean?-forward x-forward) (boolean? x-forward))

(define (real?-forward x-forward)
 (and (pair? x-forward) (real? (car x-forward))))

(define (pair?-forward x-forward)
 ;; needs work: not
 (and (pair? x-forward) (if (real? (car x-forward)) #f #t)))

(define (procedure?-forward x-forward) (procedure? x-forward))

(define (car-forward x-forward) (car x-forward))

(define (cdr-forward x-forward) (cdr x-forward))

(define (cons-procedure-forward x1-forward)
 ;; This assumes that the PT of procedure is eliminated from the FT of
 ;; procedure.
 (lambda (x2-forward) ((cons-procedure x1-forward) x2-forward)))

(define (if-procedure-forward x1-forward x2-forward x3-forward)
 (if-procedure x1-forward x2-forward x3-forward))

(define (eq?-forward x1-forward x2-forward)
 (j* (eq? (forward-primal x1-forward) (forward-primal x2-forward))))

(define (reverse-zero-forward x-forward)
 (j* (reverse-zero (forward-primal x-forward))))

(define (plus-forward x1-forward x2-forward)
 (forward-conjoin
  (plus (forward-primal x1-forward) (forward-primal x2-forward))
  (plus (forward-adjoint x1-forward) (forward-adjoint x2-forward))))

(define (forward-map-closure-forward x1-forward x2-forward)
 ;; This assumes that the PT of procedure is eliminated from the FT of
 ;; procedure.
 (j* (forward-map-closure
      (forward-primal x1-forward) (forward-primal x2-forward))))

(define (forward-map-closure-inverse-forward x1-forward x2-forward)
 ;; This assumes that the PT of procedure is eliminated from the FT of
 ;; procedure.
 (j* (forward-map-closure-inverse
      (forward-primal x1-forward) (forward-primal x2-forward))))

(define (reverse-map-closure-forward x1-forward x2-forward)
 ;; This assumes that the PT of procedure is eliminated from the FT of
 ;; procedure.
 (j* (reverse-map-closure
      (forward-primal x1-forward) (forward-primal x2-forward))))

(define (reverse-map-closure-inverse-forward x1-forward x2-forward)
 ;; This assumes that the PT of procedure is eliminated from the FT of
 ;; procedure.
 (j* (reverse-map-closure-inverse
      (forward-primal x1-forward) (forward-primal x2-forward))))

(define (write-forward x-forward) (write x-forward))

(define (forward-primal x-forward)
 (cond
  ;; This assumes that the PT of null is eliminated from the FT of null.
  ((null? x-forward) x-forward)
  ;; This assumes that the PT of boolean is eliminated from the FT of boolean.
  ((boolean? x-forward) x-forward)
  ((pair? x-forward)
   (if (real? (car x-forward))
       (car x-forward)
       ;; This assumes interleaved FT.
       (cons (forward-primal (car x-forward))
	     (forward-primal (cdr x-forward)))))
  ;; These assume that the PT of procedure is eliminated from the FT of
  ;; procedure.
  ((eq? x-forward +-forward) +)
  ((eq? x-forward --forward) -)
  ((eq? x-forward *-forward) *)
  ((eq? x-forward /-forward) /)
  ((eq? x-forward sqrt-forward) sqrt)
  ((eq? x-forward exp-forward) exp)
  ((eq? x-forward log-forward) log)
  ((eq? x-forward sin-forward) sin)
  ((eq? x-forward cos-forward) cos)
  ((eq? x-forward atan-forward) atan)
  ((eq? x-forward =-forward) =)
  ((eq? x-forward <-forward) <)
  ((eq? x-forward >-forward) >)
  ((eq? x-forward <=-forward) <=)
  ((eq? x-forward >=-forward) >=)
  ((eq? x-forward zero?-forward) zero?)
  ((eq? x-forward positive?-forward) positive?)
  ((eq? x-forward negative?-forward) negative?)
  ((eq? x-forward null?-forward) null?)
  ((eq? x-forward boolean?-forward) boolean?)
  ((eq? x-forward real?-forward) real?)
  ((eq? x-forward pair?-forward) pair?)
  ((eq? x-forward procedure?-forward) procedure?)
  ((eq? x-forward car-forward) car)
  ((eq? x-forward cdr-forward) cdr)
  ((eq? x-forward cons-procedure-forward) cons-procedure)
  ((eq? x-forward if-procedure-forward) if-procedure)
  ((eq? x-forward eq?-forward) eq?)
  ((eq? x-forward reverse-zero-forward) reverse-zero)
  ((eq? x-forward plus-forward) plus)
  ((eq? x-forward forward-map-closure-forward) forward-map-closure)
  ((eq? x-forward forward-map-closure-inverse-forward)
   forward-map-closure-inverse)
  ((eq? x-forward reverse-map-closure-forward) reverse-map-closure)
  ((eq? x-forward reverse-map-closure-inverse-forward)
   reverse-map-closure-inverse)
  ((eq? x-forward write-forward) write)
  (else (forward-map-closure-inverse forward-primal x-forward))))

(define (forward-adjoint x-forward)
 (cond
  ;; This assumes that the PT of null is eliminated from the FT of null.
  ((null? x-forward) '())
  ;; This assumes that the PT of boolean is eliminated from the FT of boolean.
  ((boolean? x-forward) '())
  ((pair? x-forward)
   (if (real? (car x-forward))
       (cdr x-forward)
       ;; This assumes interleaved FT.
       (cons (forward-adjoint (car x-forward))
	     (forward-adjoint (cdr x-forward)))))
  ;; This assumes that the PT of procedure is eliminated from the FT of
  ;; procedure.
  ;; needs work: Is the PT of procedure really null?
  (else '())))

(define (forward-conjoin x x-acute)
 (cond
  ;; This assumes that the PT of null is eliminated from the FT of null.
  ;; This doesn't check that x-acute is null.
  ((null? x) x)
  ;; This assumes that the PT of boolean is eliminated from the FT of boolean.
  ;; This doesn't check that x-acute is null.
  ((boolean? x) x)
  ;; This doesn't check that x-acute is real.
  ((real? x) (cons x x-acute))
  ;; This assumes interleaved FT.
  ((pair? x) (cons (forward-conjoin (car x) (car x-acute))
		   (forward-conjoin (cdr x) (cdr x-acute))))
  ;; These assume that the PT of procedure is eliminated from the FT of
  ;; procedure.
  ;; These don't check that x-acute is null.
  ;; needs work: Is the PT of procedure really null?
  ((eq? x +) +-forward)
  ((eq? x -) --forward)
  ((eq? x *) *-forward)
  ((eq? x /) /-forward)
  ((eq? x sqrt) sqrt-forward)
  ((eq? x exp) exp-forward)
  ((eq? x log) log-forward)
  ((eq? x sin) sin-forward)
  ((eq? x cos) cos-forward)
  ((eq? x atan) atan-forward)
  ((eq? x =) =-forward)
  ((eq? x <) <-forward)
  ((eq? x >) >-forward)
  ((eq? x <=) <=-forward)
  ((eq? x >=) >=-forward)
  ((eq? x zero?) zero?-forward)
  ((eq? x positive?) positive?-forward)
  ((eq? x negative?) negative?-forward)
  ((eq? x null?) null?-forward)
  ((eq? x boolean?) boolean?-forward)
  ((eq? x real?) real?-forward)
  ((eq? x pair?) pair?-forward)
  ((eq? x procedure?) procedure?-forward)
  ((eq? x car) car-forward)
  ((eq? x cdr) cdr-forward)
  ((eq? x cons-procedure) cons-procedure-forward)
  ((eq? x if-procedure) if-procedure-forward)
  ((eq? x eq?) eq?-forward)
  ((eq? x reverse-zero) reverse-zero-forward)
  ((eq? x plus) plus-forward)
  ((eq? x forward-map-closure) forward-map-closure-forward)
  ((eq? x forward-map-closure-inverse) forward-map-closure-inverse-forward)
  ((eq? x reverse-map-closure) reverse-map-closure-forward)
  ((eq? x reverse-map-closure-inverse) reverse-map-closure-inverse-forward)
  ((eq? x write) write-forward)
  ;; needs work: It is not really possible to do this case.
  (else (forward-map-closure j* x))))

(define (j* x)
 (cond
  ;; This assumes that the PT of null is eliminated from the FT of null.
  ((null? x) x)
  ;; This assumes that the PT of boolean is eliminated from the FT of boolean.
  ((boolean? x) x)
  ((real? x) (cons x 0))
  ;; This assumes interleaved FT.
  ((pair? x) (cons (j* (car x)) (j* (cdr x))))
  ;; These assume that the PT of procedure is eliminated from the FT of
  ;; procedure.
  ((eq? x +) +-forward)
  ((eq? x -) --forward)
  ((eq? x *) *-forward)
  ((eq? x /) /-forward)
  ((eq? x sqrt) sqrt-forward)
  ((eq? x exp) exp-forward)
  ((eq? x log) log-forward)
  ((eq? x sin) sin-forward)
  ((eq? x cos) cos-forward)
  ((eq? x atan) atan-forward)
  ((eq? x =) =-forward)
  ((eq? x <) <-forward)
  ((eq? x >) >-forward)
  ((eq? x <=) <=-forward)
  ((eq? x >=) >=-forward)
  ((eq? x zero?) zero?-forward)
  ((eq? x positive?) positive?-forward)
  ((eq? x negative?) negative?-forward)
  ((eq? x null?) null?-forward)
  ((eq? x boolean?) boolean?-forward)
  ((eq? x real?) real?-forward)
  ((eq? x pair?) pair?-forward)
  ((eq? x procedure?) procedure?-forward)
  ((eq? x car) car-forward)
  ((eq? x cdr) cdr-forward)
  ((eq? x cons-procedure) cons-procedure-forward)
  ((eq? x if-procedure) if-procedure-forward)
  ((eq? x eq?) eq?-forward)
  ((eq? x reverse-zero) reverse-zero-forward)
  ((eq? x plus) plus-forward)
  ((eq? x forward-map-closure) forward-map-closure-forward)
  ((eq? x forward-map-closure-inverse) forward-map-closure-inverse-forward)
  ((eq? x reverse-map-closure) reverse-map-closure-forward)
  ((eq? x reverse-map-closure-inverse) reverse-map-closure-inverse-forward)
  ((eq? x write) write-forward)
  (else (forward-map-closure j* x))))

;;; We perform arithmetic between primals and sensitivities to yield
;;; sensitivities.

(define (+-reverse x1-reverse x2-reverse)
 (cons (+ x1-reverse x2-reverse)
       (lambda (y-grave)
	(cons (reverse-zero +-reverse) (cons y-grave y-grave)))))

(define (--reverse x1-reverse x2-reverse)
 (cons (- x1-reverse x2-reverse)
       (lambda (y-grave)
	(cons (reverse-zero --reverse) (cons y-grave (- 0 y-grave))))))

(define (*-reverse x1-reverse x2-reverse)
 (cons (* x1-reverse x2-reverse)
       (lambda (y-grave)
	(cons (reverse-zero *-reverse)
	      (cons (* x2-reverse y-grave) (* x1-reverse y-grave))))))

(define (/-reverse x1-reverse x2-reverse)
 (cons (/ x1-reverse x2-reverse)
       (lambda (y-grave)
	(cons (reverse-zero /-reverse)
	      (cons (/ y-grave x2-reverse)
		    (- 0
		       (/ (* x1-reverse y-grave)
			  (* x2-reverse x2-reverse))))))))

(define (sqrt-reverse x-reverse)
 (cons (sqrt x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero sqrt-reverse)
	      (/ y-grave (* 2 (sqrt x-reverse)))))))

(define (exp-reverse x-reverse)
 (cons (exp x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero exp-reverse) (* (exp x-reverse) y-grave)))))

(define (log-reverse x-reverse)
 (cons (log x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero log-reverse) (/ y-grave x-reverse)))))

(define (sin-reverse x-reverse)
 (cons (sin x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero sin-reverse) (* (cos x-reverse) y-grave)))))

(define (cos-reverse x-reverse)
 (cons (cos x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero cos-reverse) (- 0 (* (sin x-reverse) y-grave))))))

(define (atan-reverse x1-reverse x2-reverse)
 (cons (atan x2-reverse x1-reverse)
       (lambda (y-grave)
	(cons (reverse-zero atan-reverse)
	      (cons (- 0
		       (/ (* x2-reverse y-grave)
			  (+ (* x1-reverse x1-reverse)
			     (* x2-reverse x2-reverse))))
		    (/ (* x1-reverse y-grave)
		       (+ (* x1-reverse x1-reverse)
			  (* x2-reverse x2-reverse))))))))

(define (=-reverse x1-reverse x2-reverse)
 (cons (= x1-reverse x2-reverse)
       (lambda (y-grave)
	(cons (reverse-zero =-reverse)
	      (cons (reverse-zero x1-reverse) (reverse-zero x2-reverse))))))

(define (<-reverse x1-reverse x2-reverse)
 (cons (< x1-reverse x2-reverse)
       (lambda (y-grave)
	(cons (reverse-zero <-reverse)
	      (cons (reverse-zero x1-reverse) (reverse-zero x2-reverse))))))

(define (>-reverse x1-reverse x2-reverse)
 (cons (> x1-reverse x2-reverse)
       (lambda (y-grave)
	(cons (reverse-zero >-reverse)
	      (cons (reverse-zero x1-reverse) (reverse-zero x2-reverse))))))

(define (<=-reverse x1-reverse x2-reverse)
 (cons (<= x1-reverse x2-reverse)
       (lambda (y-grave)
	(cons (reverse-zero <=-reverse)
	      (cons (reverse-zero x1-reverse) (reverse-zero x2-reverse))))))

(define (>=-reverse x1-reverse x2-reverse)
 (cons (>= x1-reverse x2-reverse)
       (lambda (y-grave)
	(cons (reverse-zero >=-reverse)
	      (cons (reverse-zero x1-reverse) (reverse-zero x2-reverse))))))

(define (zero?-reverse x-reverse)
 (cons (zero? x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero zero?-reverse) (reverse-zero x-reverse)))))

(define (positive?-reverse x-reverse)
 (cons (positive? x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero positive?-reverse) (reverse-zero x-reverse)))))

(define (negative?-reverse x-reverse)
 (cons (negative? x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero negative?-reverse) (reverse-zero x-reverse)))))

(define (null?-reverse x-reverse)
 (cons (null? x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero null?-reverse) (reverse-zero x-reverse)))))

(define (boolean?-reverse x-reverse)
 (cons (boolean? x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero boolean?-reverse) (reverse-zero x-reverse)))))

(define (real?-reverse x-reverse)
 (cons (real? x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero real?-reverse) (reverse-zero x-reverse)))))

(define (pair?-reverse x-reverse)
 (cons (pair? x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero pair?-reverse) (reverse-zero x-reverse)))))

(define (procedure?-reverse x-reverse)
 (cons (procedure? x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero procedure?-reverse) (reverse-zero x-reverse)))))

(define (car-reverse x-reverse)
 (cons (car x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero car-reverse)
	      (cons y-grave (reverse-zero (cdr x-reverse)))))))

(define (cdr-reverse x-reverse)
 (cons (cdr x-reverse)
       (lambda (y-grave)
	(cons (reverse-zero cdr-reverse)
	      (cons (reverse-zero (car x-reverse)) y-grave)))))

(define (cons-procedure-reverse x1-reverse)
 (cons (letrec ((self (lambda (x2-reverse)
		       (cons (cons x1-reverse x2-reverse)
			     (lambda (y-grave)
			      (cons
			       ;; This assumes that x1 is the first of more
			       ;; than one free variables.
			       (cons (car y-grave) (cdr (reverse-zero self)))
			       (cdr y-grave)))))))
	self)
       (lambda (y-grave)
	(cons (reverse-zero cons-procedure-reverse)
	      ;; This assumes that x1 is the first of more than one free
	      ;; variables.
	      (car y-grave)))))

(define (if-procedure-reverse x1-reverse x2-reverse x3-reverse)
 (if-procedure x1-reverse
	       (cons x2-reverse
		     (lambda (y-grave)
		      (cons (reverse-zero if-procedure-reverse)
			    (cons* (reverse-zero x1-reverse)
				   y-grave
				   (reverse-zero x3-reverse)))))
	       (cons x3-reverse
		     (lambda (y-grave)
		      (cons (reverse-zero if-procedure-reverse)
			    (cons* (reverse-zero x1-reverse)
				   (reverse-zero x2-reverse)
				   y-grave))))))

(define (eq?-reverse x1-reverse x2-reverse)
 (cons (eq? (reverse-primal x1-reverse) (reverse-primal x2-reverse))
       (lambda (y-grave)
	(cons (reverse-zero eq?-reverse)
	      (cons (reverse-zero x1-reverse) (reverse-zero x2-reverse))))))

(define (reverse-zero-reverse x-reverse)
 (cons (reverse-zero (reverse-primal x-reverse))
       (lambda (y-grave)
	(cons (reverse-zero reverse-zero-reverse) (reverse-zero x-reverse)))))

(define (plus-reverse x1-reverse x2-reverse)
 (cons (plus x1-reverse x2-reverse)
       (lambda (y-grave)
	(cons (reverse-zero plus-reverse) (cons y-grave y-grave)))))

(define (write-reverse x-reverse)
 (cons (write x-reverse)
       (lambda (y-grave) (cons (reverse-zero write-reverse) y-grave))))

(define (reverse-primal x-reverse)
 (cond
  ((null? x-reverse) x-reverse)
  ((boolean? x-reverse) x-reverse)
  ((real? x-reverse) x-reverse)
  ((pair? x-reverse)
   (cons (reverse-primal (car x-reverse)) (reverse-primal (cdr x-reverse))))
  ((eq? x-reverse +-reverse) +)
  ((eq? x-reverse --reverse) -)
  ((eq? x-reverse *-reverse) *)
  ((eq? x-reverse /-reverse) /)
  ((eq? x-reverse sqrt-reverse) sqrt)
  ((eq? x-reverse exp-reverse) exp)
  ((eq? x-reverse log-reverse) log)
  ((eq? x-reverse sin-reverse) sin)
  ((eq? x-reverse cos-reverse) cos)
  ((eq? x-reverse atan-reverse) atan)
  ((eq? x-reverse =-reverse) =)
  ((eq? x-reverse <-reverse) <)
  ((eq? x-reverse >-reverse) >)
  ((eq? x-reverse <=-reverse) <=)
  ((eq? x-reverse >=-reverse) >=)
  ((eq? x-reverse zero?-reverse) zero?)
  ((eq? x-reverse positive?-reverse) positive?)
  ((eq? x-reverse negative?-reverse) negative?)
  ((eq? x-reverse null?-reverse) null?)
  ((eq? x-reverse boolean?-reverse) boolean?)
  ((eq? x-reverse real?-reverse) real?)
  ((eq? x-reverse pair?-reverse) pair?)
  ((eq? x-reverse procedure?-reverse) procedure?)
  ((eq? x-reverse car-reverse) car)
  ((eq? x-reverse cdr-reverse) cdr)
  ((eq? x-reverse cons-procedure-reverse) cons-procedure)
  ((eq? x-reverse if-procedure-reverse) if-procedure)
  ((eq? x-reverse eq?-reverse) eq?)
  ((eq? x-reverse reverse-zero-reverse) reverse-zero)
  ((eq? x-reverse plus-reverse) plus)
  ;; needs work: forward-map-closure
  ;; needs work: forward-map-closure-inverse
  ;; needs work: reverse-map-closure
  ;; needs work: reverse-map-closure-inverse
  ((eq? x-reverse write-reverse) write)
  (else (reverse-map-closure-inverse reverse-primal x-reverse))))

(define (*j x)
 (cond ((null? x) x)
       ((boolean? x) x)
       ((real? x) x)
       ((pair? x) (cons (*j (car x)) (*j (cdr x))))
       ((eq? x +) +-reverse)
       ((eq? x -) --reverse)
       ((eq? x *) *-reverse)
       ((eq? x /) /-reverse)
       ((eq? x sqrt) sqrt-reverse)
       ((eq? x exp) exp-reverse)
       ((eq? x log) log-reverse)
       ((eq? x sin) sin-reverse)
       ((eq? x cos) cos-reverse)
       ((eq? x atan) atan-reverse)
       ((eq? x =) =-reverse)
       ((eq? x <) <-reverse)
       ((eq? x >) >-reverse)
       ((eq? x <=) <=-reverse)
       ((eq? x >=) >=-reverse)
       ((eq? x zero?) zero?-reverse)
       ((eq? x positive?) positive?-reverse)
       ((eq? x negative?) negative?-reverse)
       ((eq? x null?) null?-reverse)
       ((eq? x boolean?) boolean?-reverse)
       ((eq? x real?) real?-reverse)
       ((eq? x pair?) pair?-reverse)
       ((eq? x procedure?) procedure?-reverse)
       ((eq? x car) car-reverse)
       ((eq? x cdr) cdr-reverse)
       ((eq? x cons-procedure) cons-procedure-reverse)
       ((eq? x if-procedure) if-procedure-reverse)
       ((eq? x eq?) eq?-reverse)
       ((eq? x reverse-zero) reverse-zero-reverse)
       ((eq? x plus) plus-reverse)
       ;; needs work: forward-map-closure
       ;; needs work: forward-map-closure-inverse
       ;; needs work: reverse-map-closure
       ;; needs work: reverse-map-closure-inverse
       ((eq? x write) write-reverse)
       (else (reverse-map-closure *j x))))
