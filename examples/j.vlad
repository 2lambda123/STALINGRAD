(define (j* x)
 (cond
  ((null? x) x)
  ((boolean? x) x)
  ((key? x) x)
  ((real? x) x)
  ((pair? x) (cons (j* (car x)) (j* (cdr x))))
  ((eq? x +)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (+ x1 x2) (+ x1-acute x2-acute))))
  ((eq? x -)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (- x1 x2) (- x1-acute x2-acute))))
  ((eq? x *)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (* x1 x2) (+ (* x2 x1-acute) (* x1 x2-acute)))))
  ((eq? x /)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (/ x1 x2) (/ (- (* x2 x1-acute) (* x1 x2-acute)) (* x2 x2)))))
  ((eq? x sqrt)
   (lambda (x x-acute) (cons (sqrt x) (/ x-acute (* 2 (sqrt x))))))
  ((eq? x exp) (lambda (x x-acute) (cons (exp x) (* (exp x) x-acute))))
  ((eq? x log) (lambda (x x-acute) (cons (log x) (/ x-acute x))))
  ((eq? x sin) (lambda (x x-acute) (cons (sin x) (* (cos x) x-acute))))
  ((eq? x cos) (lambda (x x-acute) (cons (cos x) (- 0 (* (sin x) x-acute)))))
  ((eq? x atan)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (atan x2 x1)
	  (/ (- (* x1 x2-acute) (* x2 x1-acute)) (+ (* x1 x1) (* x2 x2))))))
  ((eq? x =)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (= x1 x2) '())))
  ((eq? x <)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (< x1 x2) '())))
  ((eq? x >)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (> x1 x2) '())))
  ((eq? x <=)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (<= x1 x2) '())))
  ((eq? x >=)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (>= x1 x2) '())))
  ((eq? x zero?) (lambda (x x-acute) (cons (zero? x) '())))
  ((eq? x positive?) (lambda (x x-acute) (cons (positive? x) '())))
  ((eq? x negative?) (lambda (x x-acute) (cons (negative? x) '())))
  ((eq? x null?) (lambda (x x-acute) (cons (null? x) '())))
  ((eq? x boolean?) (lambda (x x-acute) (cons (boolean? x) '())))
  ((eq? x key?) (lambda (x x-acute) (cons (key? x) '())))
  ((eq? x real?) (lambda (x x-acute) (cons (real? x) '())))
  ((eq? x pair?) (lambda (x x-acute) (cons (pair? x) '())))
  ((eq? x procedure?) (lambda (x x-acute) (cons (procedure? x) '())))
  ((eq? x car)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons x1 x1-acute)))
  ((eq? x cdr)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons x2 x2-acute)))
  ((eq? x cons-procedure)
   (lambda (x1 x1-acute)
    (cons (lambda (x2 x2-acute) (cons (cons x1 x2) (cons x1-acute x2-acute)))
	  '())))
  ((eq? x if-procedure)
   (lambda (x1 x1-acute)
    (cons (lambda (x2 x2-acute)
	   (cons (lambda (x3 x3-acute)
		  (if x1 (cons x2 x2-acute) (cons x3 x3-acute)))
		 '()))
	  '())))
  ((eq? x eq?)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (eq? x1 x2) '())))
  ((eq? x key=?)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (key=? x1 x2) '())))
  ((eq? x zero) (lambda (x x-acute) (cons (zero x) (zero x-acute))))
  ((eq? x add) (j* (lambda (n r x) (cons (cons n (zero x)) r))))
  ((eq? x accumulate)
   (j* (lambda (n r x)
	(letrec ((plus (lambda (x1 x2)
			(cond ((null? x1) '())
			      ((real? x1) (+ x1 x2))
			      (else (cons (plus (car x1) (car x2))
					  (plus (cdr x1) (cdr x2)))))))
		 (accumulate
		  (lambda (n r x)
		   (if (key=? (car (car r)) n)
		       (cons (cons n (plus x (cdr (car r)))) (cdr r))
		       (cons (car r) (accumulate n (cdr r) x))))))
	 (accumulate n r x)))))
  ((eq? x exit)
   (j* (lambda (n r)
	(letrec ((lookup (lambda (n r)
			  (if (key=? (car (car r)) n)
			      (cdr (car r))
			      (lookup n (cdr r)))))
		 (delete (lambda (n r)
			  (if (key=? (car (car r)) n)
			      (cdr r)
			      (cons (car r) (delete n (cdr r)))))))
	 (cons (lookup n r) (delete n r))))))
  ;; needs work
  ((eq? x map-closure-forward) map-closure-forward)
  ;; needs work
  ((eq? x map-closure-reverse) map-closure-reverse)
  ((eq? x write) write)
  (else (map-closure-forward j* x))))

(define (*j x)
 (cond
  ((null? x) x)
  ((boolean? x) x)
  ((key? x) x)
  ((real? x) x)
  ((pair? x) (cons (*j (car x)) (*j (cdr x))))
  ((eq? x +)
   (lambda (z-tilde (cons x1 x2) x-tilde)
    (cons (+ x1 x2)
	  (lambda (y-grave rho) (x-tilde (cons y-grave y-grave) rho)))))
  ((eq? x -)
   (lambda (z-tilde (cons x1 x2) x-tilde)
    (cons (- x1 x2)
	  (lambda (y-grave rho) (x-tilde (cons y-grave (- 0 y-grave)) rho)))))
  ((eq? x *)
   (lambda (z-tilde (cons x1 x2) x-tilde)
    (cons (* x1 x2)
	  (lambda (y-grave rho)
	   (x-tilde (cons (* x2 y-grave) (* x1 y-grave)) rho)))))
  ((eq? x /)
   (lambda (z-tilde (cons x1 x2) x-tilde)
    (cons
     (/ x1 x2)
     (lambda (y-grave rho)
      (x-tilde (cons (/ y-grave x2) (- 0 (/ (* x1 y-grave) (* x2 x2))))
	       rho)))))
  ((eq? x sqrt)
   (lambda (z-tilde x x-tilde)
    (cons (sqrt x)
	  (lambda (y-grave rho) (x-tilde (/ y-grave (* 2 (sqrt x))) rho)))))
  ((eq? x exp)
   (lambda (z-tilde x x-tilde)
    (cons (exp x) (lambda (y-grave rho) (x-tilde (* (exp x) y-grave) rho)))))
  ((eq? x log)
   (lambda (z-tilde x x-tilde)
    (cons (log x) (lambda (y-grave rho) (x-tilde (/ y-grave x) rho)))))
  ((eq? x sin)
   (lambda (z-tilde x x-tilde)
    (cons (sin x) (lambda (y-grave rho) (x-tilde (* (cos x) y-grave) rho)))))
  ((eq? x cos)
   (lambda (z-tilde x x-tilde)
    (cons (cos x)
	  (lambda (y-grave rho) (x-tilde (- 0 (* (sin x) y-grave)) rho)))))
  ((eq? x atan)
   (lambda (z-tilde (cons x1 x2) x-tilde)
    (cons (atan x2 x1)
	  (lambda (y-grave rho)
	   (x-tilde (cons (- 0 (/ (* x2 y-grave) (+ (* x1 x1) (* x2 x2))))
			  (/ (* x1 y-grave) (+ (* x1 x1) (* x2 x2))))
		    rho)))))
  ((eq? x =) (lambda (z-tilde (cons x1 x2) x-tilde) (cons (= x1 x2) cdr)))
  ((eq? x <) (lambda (z-tilde (cons x1 x2) x-tilde) (cons (< x1 x2) cdr)))
  ((eq? x >) (lambda (z-tilde (cons x1 x2) x-tilde) (cons (> x1 x2) cdr)))
  ((eq? x <=) (lambda (z-tilde (cons x1 x2) x-tilde) (cons (<= x1 x2) cdr)))
  ((eq? x >=) (lambda (z-tilde (cons x1 x2) x-tilde) (cons (>= x1 x2) cdr)))
  ((eq? x zero?) (lambda (z-tilde x x-tilde) (cons (zero? x) cdr)))
  ((eq? x positive?) (lambda (z-tilde x x-tilde) (cons (positive? x) cdr)))
  ((eq? x negative?) (lambda (z-tilde x x-tilde) (cons (negative? x) cdr)))
  ((eq? x null?) (lambda (z-tilde x x-tilde) (cons (null? x) cdr)))
  ((eq? x boolean?) (lambda (z-tilde x x-tilde) (cons (boolean? x) cdr)))
  ((eq? x key?) (lambda (z-tilde x x-tilde) (cons (key? x) cdr)))
  ((eq? x real?) (lambda (z-tilde x x-tilde) (cons (real? x) cdr)))
  ((eq? x pair?) (lambda (z-tilde x x-tilde) (cons (pair? x) cdr)))
  ((eq? x procedure?) (lambda (z-tilde x x-tilde) (cons (procedure? x) cdr)))
  ((eq? x car)
   (lambda (z-tilde (cons x1 x2) x-tilde)
    (cons x1 (lambda (y-grave rho) (x-tilde (cons y-grave (zero x2)) rho)))))
  ((eq? x cdr)
   (lambda (z-tilde (cons x1 x2) x-tilde)
    (cons x2 (lambda (y-grave rho) (x-tilde (cons (zero x1) y-grave) rho)))))
  ((eq? x cons-procedure)
   (lambda (xs1-tilde x1 x1-tilde)
    (cons (lambda (xs2-tilde x2 x2-tilde)
	   (cons (cons x1 x2)
		 (lambda ((cons y1-grave y2-grave) rho)
		  (x2-tilde y2-grave (x1-tilde y1-grave rho)))))
	  ;; needs work
	  cdr)))
  ((eq? x if-procedure)
   (lambda (xs1-tilde x1 x1-tilde)
    (cons (lambda (xs2-tilde x2 x2-tilde)
	   (cons (lambda (xs3-tilde x3 x3-tilde)
		  (if x1 (cons x2 x2-tilde) (cons x3 x3-tilde)))
		 ;; needs work
		 cdr))
	  ;; needs work
	  cdr)))
  ((eq? x eq?) (lambda (z-tilde (cons x1 x2) x-tilde) (cons (eq? x1 x2) cdr)))
  ((eq? x key=?)
   (lambda (z-tilde (cons x1 x2) x-tilde) (cons (key=? x1 x2) cdr)))
  ((eq? x zero) (lambda (z-tilde x x-tilde) (cons (zero x) cdr)))
  ((eq? x add) (*j (lambda (n r x) (cons (cons n (zero x)) r))))
  ((eq? x accumulate)
   (*j (lambda (n r x)
	(letrec ((plus (lambda (x1 x2)
			(cond ((null? x1) '())
			      ((real? x1) (+ x1 x2))
			      (else (cons (plus (car x1) (car x2))
					  (plus (cdr x1) (cdr x2)))))))
		 (accumulate
		  (lambda (n r x)
		   (if (key=? (car (car r)) n)
		       (cons (cons n (plus x (cdr (car r)))) (cdr r))
		       (cons (car r) (accumulate n (cdr r) x))))))
	 (accumulate n r x)))))
  ((eq? x exit)
   (*j (lambda (n r)
	(letrec ((lookup (lambda (n r)
			  (if (key=? (car (car r)) n)
			      (cdr (car r))
			      (lookup n (cdr r)))))
		 (delete (lambda (n r)
			  (if (key=? (car (car r)) n)
			      (cdr r)
			      (cons (car r) (delete n (cdr r)))))))
	 (cons (lookup n r) (delete n r))))))
  ;; needs work
  ((eq? x map-closure-forward) map-closure-forward)
  ;; needs work
  ((eq? x map-closure-reverse) map-closure-reverse)
  ;; needs work
  ((eq? x write) write)
  (else (map-closure-reverse *j x))))
