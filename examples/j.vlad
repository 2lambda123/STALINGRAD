(define (null) '())

(define (true) #t)

(define (false) #f)

(define (naught) 0)

(define (curried-equal? x1)
 (lambda (x2)
  ((((((((((((((equal?-primitive curried-equal?)
	       =)
	      null?)
	     boolean?)
	    real?)
	   pair?)
	  car)
	 cdr)
	cons-procedure)
       if-procedure)
      true)
     false)
    x1)
   x2)))

(define (equal? x1 x2) ((curried-equal? x1) x2))

(define (curried-plus x1)
 (lambda (x2)
  ((((((((((((((plus-primitive curried-plus)
	       +)
	      null?)
	     real?)
	    pair?)
	   procedure?)
	  car)
	 cdr)
	cons-procedure)
       if-procedure)
      null)
     false)
    x1)
   x2)))

(define (plus x1 x2) ((curried-plus x1) x2))

(define (zero y)
 ((((((((zero-primitive null?)
	real?)
       pair?)
      procedure?)
     cons-procedure)
    if-procedure)
   null)
  naught))

(define (not x) (if x #f #t))

(define (conjoint-j* x)
 (cond
  ((null? x) (cons x '()))
  ((boolean? x) (cons x '()))
  ((real? x) (cons x 0))
  ((pair? x) (cons (conjoint-j* (car x)) (conjoint-j* (cdr x))))
  ((equal? x +)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (+ x1 x2) (+ x1-acute x2-acute))))
  ((equal? x -)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (- x1 x2) (- x1-acute x2-acute))))
  ((equal? x *)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (* x1 x2) (+ (* x2 x1-acute) (* x1 x2-acute)))))
  ((equal? x /)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (/ x1 x2) (/ (- (* x2 x1-acute) (* x1 x2-acute)) (* x2 x2)))))
  ((equal? x sqrt)
   (lambda (x x-acute) (cons (sqrt x) (/ x-acute (* 2 (sqrt x))))))
  ((equal? x exp) (lambda (x x-acute) (cons (exp x) (* (exp x) x-acute))))
  ((equal? x log) (lambda (x x-acute) (cons (log x) (/ x-acute x))))
  ((equal? x sin) (lambda (x x-acute) (cons (sin x) (* (cos x) x-acute))))
  ((equal? x cos)
   (lambda (x x-acute) (cons (cos x) (- 0 (* (sin x) x-acute)))))
  ((equal? x atan)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (atan x2 x1)
	  (/ (- (* x1 x2-acute) (* x2 x1-acute)) (+ (* x1 x1) (* x2 x2))))))
  ((equal? x =)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (= x1 x2) '())))
  ((equal? x <)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (< x1 x2) '())))
  ((equal? x >)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (> x1 x2) '())))
  ((equal? x <=)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (<= x1 x2) '())))
  ((equal? x >=)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (>= x1 x2) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x zero?) (lambda (x x-acute) (cons (zero? x) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x positive?) (lambda (x x-acute) (cons (positive? x) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x negative?) (lambda (x x-acute) (cons (negative? x) '())))
  ((equal? x null?) (lambda (x) (cons (and (pair? x) (null? (car x))) '())))
  ((equal? x boolean?)
   (lambda (x) (cons (and (pair? x) (boolean? (car x))) '())))
  ((equal? x real?) (lambda (x) (cons (and (pair? x) (real? (car x))) '())))
  ((equal? x pair?)
   (lambda (x)
    (cons (and (pair? x) (or (pair? (car x)) (procedure? (car x)))) '())))
  ((equal? x procedure?) (lambda (x) (cons (procedure? x) '())))
  ((equal? x car) car)
  ((equal? x cdr) cdr)
  ((equal? x cons-procedure) cons-procedure)
  ((equal? x if-procedure)
   (lambda (x1)
    (lambda (x2)
     (lambda (x3)
      (if (or (not (pair? x1)) (not (boolean? (car x1))) (car x1)) x2 x3)))))
  ((equal? x equal?-primitive) equal?-primitive)
  ((equal? x map-closure) map-closure)
  ((equal? x zero-primitive) zero-primitive)
  ((equal? x plus-primitive) plus-primitive)
  ((equal? x write) write)
  (else (map-closure conjoint-j* x))))

(define (conjoint-*j x)
 (cond
  ;; needs work: to check that y-grave is null
  ((null? x) (cons x zero))
  ;; needs work: to check that y-grave is null
  ((boolean? x) (cons x zero))
  ;; needs work: to check that y-grave is real
  ((real? x) (cons x zero))
  ((pair? x) (cons (conjoint-*j (car x)) (conjoint-*j (cdr x))))
  ((equal? x +)
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
    (cons (+ x1 x2)
	  (lambda (y-grave) (plus (x1-tilde y-grave) (x2-tilde y-grave))))))
  ((equal? x -)
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
    (cons (- x1 x2)
	  (lambda (y-grave)
	   (plus (x1-tilde y-grave) (x2-tilde (- 0 y-grave)))))))
  ((equal? x *)
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
    (cons (* x1 x2)
	  (lambda (y-grave)
	   (plus (x1-tilde (* x2 y-grave)) (x2-tilde (* x1 y-grave)))))))
  ((equal? x /)
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
    (cons (/ x1 x2)
	  (lambda (y-grave)
	   (plus (x1-tilde (/ y-grave x2))
		 (x2-tilde (- 0 (/ (* x1 y-grave) (* x2 x2)))))))))
  ((equal? x sqrt)
   (lambda (x x-tilde)
    (cons (sqrt x) (lambda (y-grave) (x-tilde (/ y-grave (* 2 (sqrt x))))))))
  ((equal? x exp)
   (lambda (x x-tilde)
    (cons (exp x) (lambda (y-grave) (x-tilde (* (exp x) y-grave))))))
  ((equal? x log)
   (lambda (x x-tilde)
    (cons (log x) (lambda (y-grave) (x-tilde (/ y-grave x))))))
  ((equal? x sin)
   (lambda (x x-tilde)
    (cons (sin x) (lambda (y-grave) (x-tilde (* (cos x) y-grave))))))
  ((equal? x cos)
   (lambda (x x-tilde)
    (cons (cos x) (lambda (y-grave) (x-tilde (- 0 (* (sin x) y-grave)))))))
  ((equal? x atan)
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
    (cons (atan x2 x1)
	  (lambda (y-grave)
	   (plus (x1-tilde (- 0 (/ (* x2 y-grave) (+ (* x1 x1) (* x2 x2)))))
		 (x2-tilde (/ (* x1 y-grave) (+ (* x1 x1) (* x2 x2)))))))))
  ((equal? x =)
   ;; needs work: to check that y-grave is null
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde)) (cons (= x1 x2) zero)))
  ((equal? x <)
   ;; needs work: to check that y-grave is null
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde)) (cons (< x1 x2) zero)))
  ((equal? x >)
   ;; needs work: to check that y-grave is null
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde)) (cons (> x1 x2) zero)))
  ((equal? x <=)
   ;; needs work: to check that y-grave is null
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde)) (cons (<= x1 x2) zero)))
  ((equal? x >=)
   ;; needs work: to check that y-grave is null
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde)) (cons (>= x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x zero?) (lambda (x x-tilde) (cons (zero? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x positive?) (lambda (x x-tilde) (cons (positive? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x negative?) (lambda (x x-tilde) (cons (negative? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x null?) (lambda (x) (cons (and (pair? x) (null? (car x))) zero)))
  ((equal? x boolean?)
   ;; needs work: to check that y-grave is null
   (lambda (x) (cons (and (pair? x) (boolean? (car x))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x real?) (lambda (x) (cons (and (pair? x) (real? (car x))) zero)))
  ((equal? x pair?)
   (lambda (x)
    ;; needs work: to check that y-grave is null
    (cons (and (pair? x) (or (pair? (car x)) (procedure? (car x)))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x procedure?) (lambda (x) (cons (procedure? x) zero)))
  ((equal? x car) car)
  ((equal? x cdr) cdr)
  ((equal? x cons-procedure) cons-procedure)
  ((equal? x if-procedure)
   (lambda (x1)
    (lambda (x2)
     (lambda (x3)
      (if (or (not (pair? x1)) (not (boolean? (car x1))) (car x1)) x2 x3)))))
  ((equal? x equal?-primitive) equal?-primitive)
  ((equal? x map-closure) map-closure)
  ((equal? x zero-primitive) zero-primitive)
  ((equal? x plus-primitive) plus-primitive)
  ((equal? x write) write)
  (else (map-closure conjoint-*j x))))

(define (conjoined-j* x)
 (cond
  ((null? x) (cons x '()))
  ((boolean? x) (cons x '()))
  ((real? x) (cons x 0))
  ((pair? x)
   (let ((x1 (conjoined-j* (car x))) (x2 (conjoined-j* (cdr x))))
    (if (procedure? x1)
	(if (procedure? x2)
	    (cons x1 x2)
	    (cons (cons x1 (car x2)) (cdr x2)))
	(if (procedure? x2)
	    (cons (cons (car x1) x2) (cdr x1))
	    (cons (cons (car x1) (car x2)) (cons (cdr x1) (cdr x2)))))))
  ((equal? x +)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (+ x1 x2) (+ x1-acute x2-acute))))
  ((equal? x -)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (- x1 x2) (- x1-acute x2-acute))))
  ((equal? x *)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (* x1 x2) (+ (* x2 x1-acute) (* x1 x2-acute)))))
  ((equal? x /)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (/ x1 x2) (/ (- (* x2 x1-acute) (* x1 x2-acute)) (* x2 x2)))))
  ((equal? x sqrt)
   (lambda (x x-acute) (cons (sqrt x) (/ x-acute (* 2 (sqrt x))))))
  ((equal? x exp) (lambda (x x-acute) (cons (exp x) (* (exp x) x-acute))))
  ((equal? x log) (lambda (x x-acute) (cons (log x) (/ x-acute x))))
  ((equal? x sin) (lambda (x x-acute) (cons (sin x) (* (cos x) x-acute))))
  ((equal? x cos)
   (lambda (x x-acute) (cons (cos x) (- 0 (* (sin x) x-acute)))))
  ((equal? x atan)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (atan x2 x1)
	  (/ (- (* x1 x2-acute) (* x2 x1-acute)) (+ (* x1 x1) (* x2 x2))))))
  ((equal? x =)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (= x1 x2) '())))
  ((equal? x <)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (< x1 x2) '())))
  ((equal? x >)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (> x1 x2) '())))
  ((equal? x <=)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (<= x1 x2) '())))
  ((equal? x >=)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (>= x1 x2) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x zero?) (lambda (x x-acute) (cons (zero? x) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x positive?) (lambda (x x-acute) (cons (positive? x) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x negative?) (lambda (x x-acute) (cons (negative? x) '())))
  ((equal? x null?) (lambda (x) (cons (and (pair? x) (null? (car x))) '())))
  ((equal? x boolean?)
   (lambda (x) (cons (and (pair? x) (boolean? (car x))) '())))
  ((equal? x real?) (lambda (x) (cons (and (pair? x) (real? (car x))) '())))
  ((equal? x pair?)
   (lambda (x)
    (cons (and (pair? x) (or (pair? (car x)) (procedure? (car x)))) '())))
  ((equal? x procedure?) (lambda (x) (cons (procedure? x) '())))
  ((equal? x car)
   (lambda (x)
    (cond ((procedure? (car x)) (car x))
	  ((procedure? (car (car x))) (car (car x)))
	  ((procedure? (cdr (car x))) (cons (car (car x)) (cdr x)))
	  (else (cons (car (car x)) (car (cdr x)))))))
  ((equal? x cdr)
   (lambda (x)
    (cond ((procedure? (car x)) (cdr x))
	  ((procedure? (car (car x))) (cons (cdr (car x)) (cdr x)))
	  ((procedure? (cdr (car x))) (cdr (car x)))
	  (else (cons (cdr (car x)) (cdr (cdr x)))))))
  ((equal? x cons-procedure)
   (lambda (x1)
    (lambda (x2)
     (if (procedure? x1)
	 (if (procedure? x2)
	     (cons x1 x2)
	     (cons (cons x1 (car x2)) (cdr x2)))
	 (if (procedure? x2)
	     (cons (cons (car x1) x2) (cdr x1))
	     (cons (cons (car x1) (car x2)) (cons (cdr x1) (cdr x2))))))))
  ((equal? x if-procedure)
   (lambda (x1)
    (lambda (x2)
     (lambda (x3)
      (if (or (not (pair? x1)) (not (boolean? (car x1))) (car x1)) x2 x3)))))
  ((equal? x equal?-primitive) equal?-primitive)
  ((equal? x map-closure) map-closure)
  ((equal? x zero-primitive) zero-primitive)
  ((equal? x plus-primitive) plus-primitive)
  ((equal? x write) write)
  (else (map-closure conjoined-j* x))))

(define (conjoined-*j x)
 (cond
  ;; needs work: to check that y-grave is null
  ((null? x) (cons x zero))
  ;; needs work: to check that y-grave is null
  ((boolean? x) (cons x zero))
  ;; needs work: to check that y-grave is real
  ((real? x) (cons x zero))
  ((pair? x)
   (let ((x1 (conjoined-*j (car x))) (x2 (conjoined-*j (cdr x))))
    (if (procedure? x1)
	(if (procedure? x2)
	    (cons x1 x2)
	    (cons (cons x1 (car x2))
		  ;; needs work: I'm not sure this is correct because it
		  ;;             doesn't do anything with the backpropagator
		  ;;             of x1.
		  (lambda (y-grave) ((cdr x2) y-grave))))
	(if (procedure? x2)
	    (cons (cons (car x1) x2)
		  ;; needs work: I'm not sure this is correct because it
		  ;;             doesn't do anything with the backpropagator
		  ;;             of x2.
		  (lambda (y-grave) ((cdr x1) y-grave)))
	    (cons (cons (car x1) (car x2))
		  (lambda (y-grave)
		   (plus ((cdr x1) (car y-grave))
			 ((cdr x2) (cdr y-grave)))))))))
  ((equal? x +)
   (lambda ((cons x1 x2) x-tilde)
    (cons (+ x1 x2) (lambda (y-grave) (x-tilde (cons y-grave y-grave))))))
  ((equal? x -)
   (lambda ((cons x1 x2) x-tilde)
    (cons (- x1 x2)
	  (lambda (y-grave) (x-tilde (cons y-grave (- 0 y-grave)))))))
  ((equal? x *)
   (lambda ((cons x1 x2) x-tilde)
    (cons (* x1 x2)
	  (lambda (y-grave) (x-tilde (cons (* x2 y-grave) (* x1 y-grave)))))))
  ((equal? x /)
   (lambda ((cons x1 x2) x-tilde)
    (cons
     (/ x1 x2)
     (lambda (y-grave)
      (x-tilde (cons (/ y-grave x2) (- 0 (/ (* x1 y-grave) (* x2 x2)))))))))
  ((equal? x sqrt)
   (lambda (x x-tilde)
    (cons (sqrt x) (lambda (y-grave) (x-tilde (/ y-grave (* 2 (sqrt x))))))))
  ((equal? x exp)
   (lambda (x x-tilde)
    (cons (exp x) (lambda (y-grave) (x-tilde (* (exp x) y-grave))))))
  ((equal? x log)
   (lambda (x x-tilde)
    (cons (log x) (lambda (y-grave) (x-tilde (/ y-grave x))))))
  ((equal? x sin)
   (lambda (x x-tilde)
    (cons (sin x) (lambda (y-grave) (x-tilde (* (cos x) y-grave))))))
  ((equal? x cos)
   (lambda (x x-tilde)
    (cons (cos x) (lambda (y-grave) (x-tilde (- 0 (* (sin x) y-grave)))))))
  ((equal? x atan)
   (lambda ((cons x1 x2) x-tilde)
    (cons
     (atan x2 x1)
     (lambda (y-grave)
      (x-tilde (cons (- 0 (/ (* x2 y-grave) (+ (* x1 x1) (* x2 x2))))
		     (/ (* x1 y-grave) (+ (* x1 x1) (* x2 x2)))))))))
  ;; needs work: to check that y-grave is null
  ((equal? x =) (lambda ((cons x1 x2) x-tilde) (cons (= x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x <) (lambda ((cons x1 x2) x-tilde) (cons (< x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x >) (lambda ((cons x1 x2) x-tilde) (cons (> x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x <=) (lambda ((cons x1 x2) x-tilde) (cons (<= x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x >=) (lambda ((cons x1 x2) x-tilde) (cons (>= x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x zero?) (lambda (x x-tilde) (cons (zero? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x positive?) (lambda (x x-tilde) (cons (positive? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x negative?) (lambda (x x-tilde) (cons (negative? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x null?) (lambda (x) (cons (and (pair? x) (null? (car x))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x boolean?)
   (lambda (x) (cons (and (pair? x) (boolean? (car x))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x real?) (lambda (x) (cons (and (pair? x) (real? (car x))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x pair?)
   (lambda (x)
    (cons (and (pair? x) (or (pair? (car x)) (procedure? (car x)))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x procedure?) (lambda (x) (cons (procedure? x) zero)))
  ((equal? x car)
   ;; (proc1 . proc2) ==> proc1
   ;; ((proc . x1) . x2) ==> proc
   ;; ((x1 . proc) . x2) ==> (x1 . x2)
   ;; ((x1 . x2) . (x3 . x4)) ==> (x1 . x3)
   (lambda (x)
    (cond ((procedure? (car x)) (car x))
	  ;; needs work: I'm not sure this is correct.
	  ((procedure? (car (car x))) (car (car x)))
	  ;; needs work: I'm not sure this is correct.
	  ((procedure? (cdr (car x))) (cons (car (car x)) (cdr x)))
	  (else (cons (car (car x))
		      (lambda (y-grave) ((cdr x) (cons y-grave (zero)))))))))
  ((equal? x cdr)
   ;; (proc1 . proc2) ==> proc2
   ;; ((proc . x1) . x2) ==> (x1 . x2)
   ;; ((x1 . proc) . x2) ==> proc
   ;; ((x1 . x2) . (x3 . x4)) ==> (x2 . x4)
   (lambda (x)
    (cond ((procedure? (car x)) (cdr x))
	  ;; needs work: I'm not sure this is correct.
	  ((procedure? (car (car x))) (cons (cdr (car x)) (cdr x)))
	  ;; needs work: I'm not sure this is correct.
	  ((procedure? (cdr (car x))) (cdr (car x)))
	  (else (cons (cdr (car x))
		      (lambda (y-grave) ((cdr x) (cons (zero) y-grave))))))))
  ((equal? x cons-procedure)
   (lambda (x1)
    (lambda (x2)
     (if (procedure? x1)
	 (if (procedure? x2)
	     (cons x1 x2)
	     (cons (cons x1 (car x2))
		   ;; needs work: I'm not sure this is correct because it
		   ;;             doesn't do anything with the backpropagator
		   ;;             of x1.
		   (lambda (y-grave) ((cdr x2) y-grave))))
	 (if (procedure? x2)
	     (cons (cons (car x1) x2)
		   ;; needs work: I'm not sure this is correct because it
		   ;;             doesn't do anything with the backpropagator
		   ;;             of x2.
		   (lambda (y-grave) ((cdr x1) y-grave)))
	     (cons (cons (car x1) (car x2))
		   (lambda (y-grave)
		    (plus ((cdr x1) (car y-grave))
			  ((cdr x2) (cdr y-grave))))))))))
  ((equal? x if-procedure)
   (lambda (x1)
    (lambda (x2)
     (lambda (x3)
      (if (or (not (pair? x1)) (not (boolean? (car x1))) (car x1)) x2 x3)))))
  ((equal? x equal?-primitive) equal?-primitive)
  ((equal? x map-closure) map-closure)
  ((equal? x zero-primitive) zero-primitive)
  ((equal? x plus-primitive) plus-primitive)
  ((equal? x write) write)
  (else (map-closure conjoined-*j x))))
