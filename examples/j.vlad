(define (equal? x1 x2)
 (((((((((((((equal?-primitive =)
	     null?)
	    boolean?)
	   real?)
	  pair?)
	 car)
	cdr)
       cons-procedure)
      if-procedure)
     (lambda () #t))
    (lambda () #f))
   x1)
  x2))

(define (plus x1 x2)
 (cond ((generic-zero? x1) x2)
       ((generic-zero? x2) x1)
       ((and (null? x1) (null? x2)) '())
       ((and (real? x1) (real? x2)) (+ x1 x2))
       ;; pairs
       (else (cons (plus (car x1) (car x2)) (plus (cdr x1) (cdr x2))))))

(define (not x) (if x #f #t))

(define (conjoint-j* x)
 (cond
  ((null? x) (cons x '()))
  ((boolean? x) (cons x '()))
  ((real? x) (cons x 0))
  ((pair? x) (cons (conjoint-j* (car x)) (conjoint-j* (cdr x))))
  ((equal? x +)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (+ x1 x2) (+ x1-acute x2-acute))))
  ((equal? x -)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (- x1 x2) (- x1-acute x2-acute))))
  ((equal? x *)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (* x1 x2) (+ (* x2 x1-acute) (* x1 x2-acute)))))
  ((equal? x /)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (/ x1 x2) (/ (- (* x2 x1-acute) (* x1 x2-acute)) (* x2 x2)))))
  ((equal? x sqrt)
   (lambda (x x-acute) (cons (sqrt x) (/ x-acute (* 2 (sqrt x))))))
  ((equal? x exp) (lambda (x x-acute) (cons (exp x) (* (exp x) x-acute))))
  ((equal? x log) (lambda (x x-acute) (cons (log x) (/ x-acute x))))
  ((equal? x sin) (lambda (x x-acute) (cons (sin x) (* (cos x) x-acute))))
  ((equal? x cos)
   (lambda (x x-acute) (cons (cos x) (- 0 (* (sin x) x-acute)))))
  ((equal? x atan)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (atan x2 x1)
	  (/ (- (* x1 x2-acute) (* x2 x1-acute)) (+ (* x1 x1) (* x2 x2))))))
  ((equal? x =)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (= x1 x2) '())))
  ((equal? x <)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (< x1 x2) '())))
  ((equal? x >)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (> x1 x2) '())))
  ((equal? x <=)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (<= x1 x2) '())))
  ((equal? x >=)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (>= x1 x2) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x zero?) (lambda (x x-acute) (cons (zero? x) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x positive?) (lambda (x x-acute) (cons (positive? x) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x negative?) (lambda (x x-acute) (cons (negative? x) '())))
  ((equal? x null?) (lambda (x) (cons (and (pair? x) (null? (car x))) '())))
  ((equal? x boolean?)
   (lambda (x) (cons (and (pair? x) (boolean? (car x))) '())))
  ((equal? x real?) (lambda (x) (cons (and (pair? x) (real? (car x))) '())))
  ((equal? x pair?)
   (lambda (x)
    (cons (and (pair? x) (or (pair? (car x)) (procedure? (car x)))) '())))
  ((equal? x procedure?) (lambda (x) (cons (procedure? x) '())))
  ((equal? x car) car)
  ((equal? x cdr) cdr)
  ((equal? x cons-procedure) cons-procedure)
  ((equal? x if-procedure)
   (lambda (x1)
    (lambda (x2)
     (lambda (x3)
      (if (or (not (pair? x1)) (not (boolean? (car x1))) (car x1)) x2 x3)))))
  ((equal? x equal?-primitive) equal?-primitive)
  ((equal? x map-closure) map-closure)
  ((equal? x zero) zero)
  ((equal? x generic-zero?) (lambda (x) (cons (generic-zero? x) '())))
  ((equal? x procedure-tree?) (lambda (x) (cons (procedure-tree? x) '())))
  ((equal? x write) write)
  ((equal? x conjoint-j*) conjoint-j*)
  ((equal? x conjoint-*j) conjoint-*j)
  ((equal? x conjoined-j*) conjoined-j*)
  ((equal? x conjoined-*j) conjoined-*j)
  (else (map-closure conjoint-j* x))))

(define (conjoint-*j x)
 (cond
  ;; needs work: to check that y-grave is null
  ((null? x) (cons x zero))
  ;; needs work: to check that y-grave is null
  ((boolean? x) (cons x zero))
  ;; needs work: to check that y-grave is real
  ((real? x) (cons x zero))
  ((pair? x) (cons (conjoint-*j (car x)) (conjoint-*j (cdr x))))
  ((equal? x +)
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
    (cons (+ x1 x2)
	  (lambda (y-grave) (plus (x1-tilde y-grave) (x2-tilde y-grave))))))
  ((equal? x -)
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
    (cons (- x1 x2)
	  (lambda (y-grave)
	   (plus (x1-tilde y-grave) (x2-tilde (- 0 y-grave)))))))
  ((equal? x *)
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
    (cons (* x1 x2)
	  (lambda (y-grave)
	   (plus (x1-tilde (* x2 y-grave)) (x2-tilde (* x1 y-grave)))))))
  ((equal? x /)
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
    (cons (/ x1 x2)
	  (lambda (y-grave)
	   (plus (x1-tilde (/ y-grave x2))
		 (x2-tilde (- 0 (/ (* x1 y-grave) (* x2 x2)))))))))
  ((equal? x sqrt)
   (lambda (x x-tilde)
    (cons (sqrt x) (lambda (y-grave) (x-tilde (/ y-grave (* 2 (sqrt x))))))))
  ((equal? x exp)
   (lambda (x x-tilde)
    (cons (exp x) (lambda (y-grave) (x-tilde (* (exp x) y-grave))))))
  ((equal? x log)
   (lambda (x x-tilde)
    (cons (log x) (lambda (y-grave) (x-tilde (/ y-grave x))))))
  ((equal? x sin)
   (lambda (x x-tilde)
    (cons (sin x) (lambda (y-grave) (x-tilde (* (cos x) y-grave))))))
  ((equal? x cos)
   (lambda (x x-tilde)
    (cons (cos x) (lambda (y-grave) (x-tilde (- 0 (* (sin x) y-grave)))))))
  ((equal? x atan)
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde))
    (cons (atan x2 x1)
	  (lambda (y-grave)
	   (plus (x1-tilde (- 0 (/ (* x2 y-grave) (+ (* x1 x1) (* x2 x2)))))
		 (x2-tilde (/ (* x1 y-grave) (+ (* x1 x1) (* x2 x2)))))))))
  ((equal? x =)
   ;; needs work: to check that y-grave is null
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde)) (cons (= x1 x2) zero)))
  ((equal? x <)
   ;; needs work: to check that y-grave is null
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde)) (cons (< x1 x2) zero)))
  ((equal? x >)
   ;; needs work: to check that y-grave is null
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde)) (cons (> x1 x2) zero)))
  ((equal? x <=)
   ;; needs work: to check that y-grave is null
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde)) (cons (<= x1 x2) zero)))
  ((equal? x >=)
   ;; needs work: to check that y-grave is null
   (lambda ((cons x1 x1-tilde) (cons x2 x2-tilde)) (cons (>= x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x zero?) (lambda (x x-tilde) (cons (zero? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x positive?) (lambda (x x-tilde) (cons (positive? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x negative?) (lambda (x x-tilde) (cons (negative? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x null?) (lambda (x) (cons (and (pair? x) (null? (car x))) zero)))
  ((equal? x boolean?)
   ;; needs work: to check that y-grave is null
   (lambda (x) (cons (and (pair? x) (boolean? (car x))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x real?) (lambda (x) (cons (and (pair? x) (real? (car x))) zero)))
  ((equal? x pair?)
   (lambda (x)
    ;; needs work: to check that y-grave is null
    (cons (and (pair? x) (or (pair? (car x)) (procedure? (car x)))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x procedure?) (lambda (x) (cons (procedure? x) zero)))
  ((equal? x car) car)
  ((equal? x cdr) cdr)
  ((equal? x cons-procedure) cons-procedure)
  ((equal? x if-procedure)
   (lambda (x1)
    (lambda (x2)
     (lambda (x3)
      (if (or (not (pair? x1)) (not (boolean? (car x1))) (car x1)) x2 x3)))))
  ((equal? x equal?-primitive) equal?-primitive)
  ((equal? x map-closure) map-closure)
  ((equal? x zero) zero)
  ((equal? x generic-zero?) (lambda (x) (cons (generic-zero? x) zero)))
  ((equal? x procedure-tree?) (lambda (x) (cons (procedure-tree? x) zero)))
  ((equal? x write) write)
  ((equal? x conjoint-j*) conjoint-j*)
  ((equal? x conjoint-*j) conjoint-*j)
  ((equal? x conjoined-j*) conjoined-j*)
  ((equal? x conjoined-*j) conjoined-*j)
  (else (map-closure conjoint-*j x))))

(define (conjoined-j* x)
 (cond
  ((null? x) (cons x '()))
  ((boolean? x) (cons x '()))
  ((real? x) (cons x 0))
  ((pair? x)
   (let ((x1 (conjoined-j* (car x))) (x2 (conjoined-j* (cdr x))))
    (if (procedure-tree? x1)
	(if (procedure-tree? x2)
	    (cons x1 x2)
	    (cons (cons x1 (car x2)) (cdr x2)))
	(if (procedure-tree? x2)
	    (cons (cons (car x1) x2) (cdr x1))
	    (cons (cons (car x1) (car x2)) (cons (cdr x1) (cdr x2)))))))
  ((equal? x +)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (+ x1 x2) (+ x1-acute x2-acute))))
  ((equal? x -)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (- x1 x2) (- x1-acute x2-acute))))
  ((equal? x *)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (* x1 x2) (+ (* x2 x1-acute) (* x1 x2-acute)))))
  ((equal? x /)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (/ x1 x2) (/ (- (* x2 x1-acute) (* x1 x2-acute)) (* x2 x2)))))
  ((equal? x sqrt)
   (lambda (x x-acute) (cons (sqrt x) (/ x-acute (* 2 (sqrt x))))))
  ((equal? x exp) (lambda (x x-acute) (cons (exp x) (* (exp x) x-acute))))
  ((equal? x log) (lambda (x x-acute) (cons (log x) (/ x-acute x))))
  ((equal? x sin) (lambda (x x-acute) (cons (sin x) (* (cos x) x-acute))))
  ((equal? x cos)
   (lambda (x x-acute) (cons (cos x) (- 0 (* (sin x) x-acute)))))
  ((equal? x atan)
   (lambda ((cons x1 x2) (cons x1-acute x2-acute))
    (cons (atan x2 x1)
	  (/ (- (* x1 x2-acute) (* x2 x1-acute)) (+ (* x1 x1) (* x2 x2))))))
  ((equal? x =)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (= x1 x2) '())))
  ((equal? x <)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (< x1 x2) '())))
  ((equal? x >)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (> x1 x2) '())))
  ((equal? x <=)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (<= x1 x2) '())))
  ((equal? x >=)
   ;; needs work: to check that x1-acute and x2-acute are real
   (lambda ((cons x1 x2) (cons x1-acute x2-acute)) (cons (>= x1 x2) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x zero?) (lambda (x x-acute) (cons (zero? x) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x positive?) (lambda (x x-acute) (cons (positive? x) '())))
  ;; needs work: to check that x-acute is real
  ((equal? x negative?) (lambda (x x-acute) (cons (negative? x) '())))
  ((equal? x null?) (lambda (x) (cons (and (pair? x) (null? (car x))) '())))
  ((equal? x boolean?)
   (lambda (x) (cons (and (pair? x) (boolean? (car x))) '())))
  ((equal? x real?) (lambda (x) (cons (and (pair? x) (real? (car x))) '())))
  ((equal? x pair?)
   (lambda (x)
    (cons (and (pair? x) (or (pair? (car x)) (procedure? (car x)))) '())))
  ((equal? x procedure?) (lambda (x) (cons (procedure? x) '())))
  ((equal? x car)
   (lambda (x)
    (cond ((procedure-tree? x) (car x))
	  ((procedure-tree? (car (car x))) (car (car x)))
	  ((procedure-tree? (cdr (car x))) (cons (car (car x)) (cdr x)))
	  (else (cons (car (car x)) (car (cdr x)))))))
  ((equal? x cdr)
   (lambda (x)
    (cond ((procedure-tree? x) (cdr x))
	  ((procedure-tree? (car (car x))) (cons (cdr (car x)) (cdr x)))
	  ((procedure-tree? (cdr (car x))) (cdr (car x)))
	  (else (cons (cdr (car x)) (cdr (cdr x)))))))
  ((equal? x cons-procedure)
   (lambda (x1)
    (lambda (x2)
     (if (procedure-tree? x1)
	 (if (procedure-tree? x2)
	     (cons x1 x2)
	     (cons (cons x1 (car x2)) (cdr x2)))
	 (if (procedure-tree? x2)
	     (cons (cons (car x1) x2) (cdr x1))
	     (cons (cons (car x1) (car x2)) (cons (cdr x1) (cdr x2))))))))
  ((equal? x if-procedure)
   (lambda (x1)
    (lambda (x2)
     (lambda (x3)
      (if (or (not (pair? x1)) (not (boolean? (car x1))) (car x1)) x2 x3)))))
  ((equal? x equal?-primitive) equal?-primitive)
  ((equal? x map-closure) map-closure)
  ((equal? x zero) (lambda () (cons (zero) (zero))))
  ((equal? x generic-zero?)
   (lambda (x) (cons (and (pair? x) (generic-zero? (car x))) '())))
  ((equal? x procedure-tree?) (lambda (x) (cons (procedure-tree? x) '())))
  ((equal? x write) write)
  ((equal? x conjoint-j*) conjoint-j*)
  ((equal? x conjoint-*j) conjoint-*j)
  ((equal? x conjoined-j*) conjoined-j*)
  ((equal? x conjoined-*j) conjoined-*j)
  (else (map-closure conjoined-j* x))))

(define (conjoined-*j x)
 (cond
  ;; needs work: to check that y-grave is null
  ((null? x) (cons x zero))
  ;; needs work: to check that y-grave is null
  ((boolean? x) (cons x zero))
  ;; needs work: to check that y-grave is real
  ((real? x) (cons x zero))
  ((pair? x)
   (let ((x1 (conjoined-*j (car x))) (x2 (conjoined-*j (cdr x))))
    (if (procedure-tree? x1)
	(if (procedure-tree? x2)
	    (cons x1 x2)
	    (cons (cons x1 (car x2)) (cdr x2)))
	(if (procedure-tree? x2)
	    (cons (cons (car x1) x2) (cdr x1))
	    (cons (cons (car x1) (car x2))
		  (lambda (y-grave)
		   (plus ((cdr x1) (car y-grave))
			 ((cdr x2) (cdr y-grave)))))))))
  ((equal? x +)
   (lambda ((cons x1 x2) x-tilde)
    (cons (+ x1 x2) (lambda (y-grave) (x-tilde (cons y-grave y-grave))))))
  ((equal? x -)
   (lambda ((cons x1 x2) x-tilde)
    (cons (- x1 x2)
	  (lambda (y-grave) (x-tilde (cons y-grave (- 0 y-grave)))))))
  ((equal? x *)
   (lambda ((cons x1 x2) x-tilde)
    (cons (* x1 x2)
	  (lambda (y-grave) (x-tilde (cons (* x2 y-grave) (* x1 y-grave)))))))
  ((equal? x /)
   (lambda ((cons x1 x2) x-tilde)
    (cons
     (/ x1 x2)
     (lambda (y-grave)
      (x-tilde (cons (/ y-grave x2) (- 0 (/ (* x1 y-grave) (* x2 x2)))))))))
  ((equal? x sqrt)
   (lambda (x x-tilde)
    (cons (sqrt x) (lambda (y-grave) (x-tilde (/ y-grave (* 2 (sqrt x))))))))
  ((equal? x exp)
   (lambda (x x-tilde)
    (cons (exp x) (lambda (y-grave) (x-tilde (* (exp x) y-grave))))))
  ((equal? x log)
   (lambda (x x-tilde)
    (cons (log x) (lambda (y-grave) (x-tilde (/ y-grave x))))))
  ((equal? x sin)
   (lambda (x x-tilde)
    (cons (sin x) (lambda (y-grave) (x-tilde (* (cos x) y-grave))))))
  ((equal? x cos)
   (lambda (x x-tilde)
    (cons (cos x) (lambda (y-grave) (x-tilde (- 0 (* (sin x) y-grave)))))))
  ((equal? x atan)
   (lambda ((cons x1 x2) x-tilde)
    (cons (atan x2 x1)
	  (lambda (y-grave)
	   (x-tilde (cons (- 0 (/ (* x2 y-grave) (+ (* x1 x1) (* x2 x2))))
			  (/ (* x1 y-grave) (+ (* x1 x1) (* x2 x2)))))))))
  ;; needs work: to check that y-grave is null
  ((equal? x =) (lambda ((cons x1 x2) x-tilde) (cons (= x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x <) (lambda ((cons x1 x2) x-tilde) (cons (< x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x >) (lambda ((cons x1 x2) x-tilde) (cons (> x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x <=) (lambda ((cons x1 x2) x-tilde) (cons (<= x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x >=) (lambda ((cons x1 x2) x-tilde) (cons (>= x1 x2) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x zero?) (lambda (x x-tilde) (cons (zero? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x positive?) (lambda (x x-tilde) (cons (positive? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x negative?) (lambda (x x-tilde) (cons (negative? x) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x null?) (lambda (x) (cons (and (pair? x) (null? (car x))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x boolean?)
   (lambda (x) (cons (and (pair? x) (boolean? (car x))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x real?) (lambda (x) (cons (and (pair? x) (real? (car x))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x pair?)
   (lambda (x)
    (cons (and (pair? x) (or (pair? (car x)) (procedure? (car x)))) zero)))
  ;; needs work: to check that y-grave is null
  ((equal? x procedure?) (lambda (x) (cons (procedure? x) zero)))
  ((equal? x car)
   (lambda (x)
    (cond ((procedure-tree? x) (car x))
	  ((procedure-tree? (car (car x))) (car (car x)))
	  ((procedure-tree? (cdr (car x))) (cons (car (car x)) (cdr x)))
	  (else (cons (car (car x))
		      (lambda (y-grave) ((cdr x) (cons y-grave (zero)))))))))
  ((equal? x cdr)
   (lambda (x)
    (cond ((procedure-tree? x) (cdr x))
	  ((procedure-tree? (car (car x))) (cons (cdr (car x)) (cdr x)))
	  ((procedure-tree? (cdr (car x))) (cdr (car x)))
	  (else (cons (cdr (car x))
		      (lambda (y-grave) ((cdr x) (cons (zero) y-grave))))))))
  ((equal? x cons-procedure)
   (lambda (x1)
    (lambda (x2)
     (if (procedure-tree? x1)
	 (if (procedure-tree? x2)
	     (cons x1 x2)
	     (cons (cons x1 (car x2)) (cdr x2)))
	 (if (procedure-tree? x2)
	     (cons (cons (car x1) x2) (cdr x1))
	     (cons (cons (car x1) (car x2))
		   (lambda (y-grave)
		    (plus ((cdr x1) (car y-grave))
			  ((cdr x2) (cdr y-grave))))))))))
  ((equal? x if-procedure)
   (lambda (x1)
    (lambda (x2)
     (lambda (x3)
      (if (or (not (pair? x1)) (not (boolean? (car x1))) (car x1)) x2 x3)))))
  ((equal? x equal?-primitive) equal?-primitive)
  ((equal? x map-closure) map-closure)
  ((equal? x zero) (lambda () (cons (zero) zero)))
  ((equal? x generic-zero?)
   (lambda (x) (cons (and (pair? x) (generic-zero? (car x))) zero)))
  ((equal? x procedure-tree?) (lambda (x) (cons (procedure-tree? x) zero)))
  ((equal? x write) write)
  ((equal? x conjoint-j*) conjoint-j*)
  ((equal? x conjoint-*j) conjoint-*j)
  ((equal? x conjoined-j*) conjoined-j*)
  ((equal? x conjoined-*j) conjoined-*j)
  (else (map-closure conjoined-*j x))))
