(define (not x) (if x #f #t))

(define (j* x)
 (cond
  ((generic-zero? x) x)
  ((null? x) (cons x '()))
  ((boolean? x) (cons x '()))
  ((real? x) (cons x 0))
  ((pair? x) (cons (j* (car x)) (j* (cdr x))))
  ((eq? x +)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (+ x1 x2) (+ x1-acute x2-acute))))
  ((eq? x -)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (- x1 x2) (- x1-acute x2-acute))))
  ((eq? x *)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (* x1 x2) (+ (* x2 x1-acute) (* x1 x2-acute)))))
  ((eq? x /)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (/ x1 x2) (/ (- (* x2 x1-acute) (* x1 x2-acute)) (* x2 x2)))))
  ((eq? x sqrt)
   (lambda (x x-acute) (cons (sqrt x) (/ x-acute (* 2 (sqrt x))))))
  ((eq? x exp) (lambda (x x-acute) (cons (exp x) (* (exp x) x-acute))))
  ((eq? x log) (lambda (x x-acute) (cons (log x) (/ x-acute x))))
  ((eq? x sin) (lambda (x x-acute) (cons (sin x) (* (cos x) x-acute))))
  ((eq? x cos) (lambda (x x-acute) (cons (cos x) (- 0 (* (sin x) x-acute)))))
  ((eq? x atan)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (atan x2 x1)
	  (/ (- (* x1 x2-acute) (* x2 x1-acute)) (+ (* x1 x1) (* x2 x2))))))
  ((eq? x =)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (= x1 x2) '())))
  ((eq? x <)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (< x1 x2) '())))
  ((eq? x >)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (> x1 x2) '())))
  ((eq? x <=)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (<= x1 x2) '())))
  ((eq? x >=)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (cons (>= x1 x2) '())))
  ((eq? x zero?) (lambda (x x-acute) (cons (zero? x) '())))
  ((eq? x positive?) (lambda (x x-acute) (cons (positive? x) '())))
  ((eq? x negative?) (lambda (x x-acute) (cons (negative? x) '())))
  ((eq? x null?) (lambda (x) (cons (and (pair? x) (null? (car x))) '())))
  ((eq? x boolean?) (lambda (x) (cons (and (pair? x) (boolean? (car x))) '())))
  ((eq? x real?) (lambda (x) (cons (and (pair? x) (real? (car x))) '())))
  ((eq? x pair?)
   (lambda (x)
    (cons (and (pair? x) (or (pair? (car x)) (procedure? (car x)))) '())))
  ((eq? x procedure?) (lambda (x) (cons (procedure? x) '())))
  ((eq? x car) car)
  ((eq? x cdr) cdr)
  ((eq? x cons-procedure) cons-procedure)
  ((eq? x if-procedure)
   (lambda (x1)
    (lambda (x2)
     (lambda (x3)
      (if (or (not (pair? x1)) (not (boolean? (car x1))) (car x1)) x2 x3)))))
  ((eq? x eq?) (lambda (x1 x2) (cons (eq? x1 x2) '())))
  ((eq? x zero) zero)
  ((eq? x generic-zero?)
   (lambda (x)
    (cons (or (generic-zero? x) (and (pair? x) (generic-zero? (car x)))) '())))
  ((eq? x plus) plus)
  ((eq? x map-closure-forward) map-closure-forward)
  ((eq? x map-closure-reverse) map-closure-reverse)
  ((eq? x write) write)
  (else (map-closure-forward j* x))))

(define (*j x)
 (cond
  ((generic-zero? x) x)
  ((null? x) x)
  ((boolean? x) x)
  ((real? x) x)
  ((pair? x) (cons (*j (car x)) (*j (cdr x))))
  ((eq? x +)
   (lambda (x1 x2)
    (cons (+ x1 x2) (lambda (y-grave) (cons (zero) (cons y-grave y-grave))))))
  ((eq? x -)
   (lambda (x1 x2)
    (cons (- x1 x2)
	  (lambda (y-grave) (cons (zero) (cons y-grave (- 0 y-grave)))))))
  ((eq? x *)
   (lambda (x1 x2)
    (cons (* x1 x2)
	  (lambda (y-grave)
	   (cons (zero) (cons (* x2 y-grave) (* x1 y-grave)))))))
  ((eq? x /)
   (lambda (x1 x2)
    (cons (/ x1 x2)
	  (lambda (y-grave)
	   (cons (zero)
		 (cons (/ y-grave x2) (- 0 (/ (* x1 y-grave) (* x2 x2)))))))))
  ((eq? x sqrt)
   (lambda (x)
    (cons (sqrt x)
	  (lambda (y-grave) (cons (zero) (/ y-grave (* 2 (sqrt x))))))))
  ((eq? x exp)
   (lambda (x)
    (cons (exp x) (lambda (y-grave) (cons (zero) (* (exp x) y-grave))))))
  ((eq? x log)
   (lambda (x) (cons (log x) (lambda (y-grave) (cons (zero) (/ y-grave x))))))
  ((eq? x sin)
   (lambda (x)
    (cons (sin x) (lambda (y-grave) (cons (zero) (* (cos x) y-grave))))))
  ((eq? x cos)
   (lambda (x)
    (cons (cos x) (lambda (y-grave) (cons (zero) (- 0 (* (sin x) y-grave)))))))
  ((eq? x atan)
   (lambda (x1 x2)
    (cons (atan x2 x1)
	  (lambda (y-grave)
	   (cons (zero)
		 (cons (- 0 (/ (* x2 y-grave) (+ (* x1 x1) (* x2 x2))))
		       (/ (* x1 y-grave) (+ (* x1 x1) (* x2 x2)))))))))
  ((eq? x =)
   (lambda (x1 x2)
    (cons (= x1 x2) (lambda (y-grave) (cons (zero) (cons (zero) (zero)))))))
  ((eq? x <)
   (lambda (x1 x2)
    (cons (< x1 x2) (lambda (y-grave) (cons (zero) (cons (zero) (zero)))))))
  ((eq? x >)
   (lambda (x1 x2)
    (cons (> x1 x2) (lambda (y-grave) (cons (zero) (cons (zero) (zero)))))))
  ((eq? x <=)
   (lambda (x1 x2)
    (cons (<= x1 x2) (lambda (y-grave) (cons (zero) (cons (zero) (zero)))))))
  ((eq? x >=)
   (lambda (x1 x2)
    (cons (>= x1 x2) (lambda (y-grave) (cons (zero) (cons (zero) (zero)))))))
  ((eq? x zero?)
   (lambda (x) (cons (zero? x) (lambda (y-grave) (cons (zero) (zero))))))
  ((eq? x positive?)
   (lambda (x) (cons (positive? x) (lambda (y-grave) (cons (zero) (zero))))))
  ((eq? x negative?)
   (lambda (x) (cons (negative? x) (lambda (y-grave) (cons (zero) (zero))))))
  ((eq? x null?)
   (lambda (x) (cons (null? x) (lambda (y-grave) (cons (zero) (zero))))))
  ((eq? x boolean?)
   (lambda (x) (cons (boolean? x) (lambda (y-grave) (cons (zero) (zero))))))
  ((eq? x real?)
   (lambda (x) (cons (real? x) (lambda (y-grave) (cons (zero) (zero))))))
  ((eq? x pair?)
   (lambda (x) (cons (pair? x) (lambda (y-grave) (cons (zero) (zero))))))
  ((eq? x procedure?)
   (lambda (x) (cons (procedure? x) (lambda (y-grave) (cons (zero) (zero))))))
  ((eq? x car)
   (lambda (x1 x2)
    (cons x1 (lambda (y-grave) (cons (zero) (cons y-grave (zero)))))))
  ((eq? x cdr)
   (lambda (x1 x2)
    (cons x2 (lambda (y-grave) (cons (zero) (cons (zero) y-grave))))))
  ((eq? x cons-procedure)
   (lambda (x1)
    (cons (lambda (x2)
	   (cons (cons x1 x2)
		 (lambda (y1-grave y2-grave) (cons y1-grave y2-grave))))
	  (lambda (x1-grave) (cons (zero) x1-grave)))))
  ((eq? x if-procedure)
   (lambda (x1)
    (cons (lambda (x2)
	   (cons (lambda (x3)
		  (if x1
		      (cons x2
			    (lambda (y-grave)
			     (cons (cons (zero) y-grave) (zero))))
		      (cons x3
			    (lambda (y-grave)
			     (cons (cons (zero) (zero)) y-grave)))))
		 (lambda (x1-grave x2-grave) (cons x1-grave x2-grave))))
	  (lambda (x1-grave) (cons (zero) x1-grave)))))
  ((eq? x eq?)
   (lambda (x1 x2)
    (cons (eq? x1 x2) (lambda (y-grave) (cons (zero) (cons (zero) (zero)))))))
  ((eq? x zero)
   (lambda (x) (cons (zero) (lambda (y-grave) (cons (zero) (zero))))))
  ((eq? x generic-zero?)
   (lambda (x)
    (cons (generic-zero? x) (lambda (y-grave) (cons (zero) (zero))))))
  ((eq? x plus)
   (lambda (x1 x2)
    (cons (plus x1 x2)
	  (lambda (y-grave) (cons (zero) (cons y-grave y-grave))))))
  ;; needs work
  ((eq? x map-closure-forward)
   (lambda (x1 x2)
    (cons (map-closure-forward x1 x2)
	  (lambda (y-grave) (cons (zero) (cons (zero) (zero)))))))
  ;; needs work
  ((eq? x map-closure-reverse)
   (lambda (x1 x2)
    (cons (map-closure-reverse x1 x2)
	  (lambda (y-grave) (cons (zero) (cons (zero) (zero)))))))
  ((eq? x write)
   (lambda (x)
    (cons (write x) (lambda (y-grave) (cons (zero) (write y-grave))))))
  (else (map-closure-reverse *j x))))
