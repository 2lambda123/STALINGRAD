(define (not x) (if x #f #t))

(define (j* x)
 (cond
  ((null? x) x)
  ((boolean? x) x)
  ((real? x) (cons x 0))
  ((pair? x) (cons (j* (car x)) (j* (cdr x))))
  ((equal? x +)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (+ x1 x2) (+ x1-acute x2-acute))))
  ((equal? x -)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (- x1 x2) (- x1-acute x2-acute))))
  ((equal? x *)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (* x1 x2) (+ (* x2 x1-acute) (* x1 x2-acute)))))
  ((equal? x /)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (/ x1 x2) (/ (- (* x2 x1-acute) (* x1 x2-acute)) (* x2 x2)))))
  ((equal? x sqrt)
   (lambda (x x-acute) (cons (sqrt x) (/ x-acute (* 2 (sqrt x))))))
  ((equal? x exp) (lambda (x x-acute) (cons (exp x) (* (exp x) x-acute))))
  ((equal? x log) (lambda (x x-acute) (cons (log x) (/ x-acute x))))
  ((equal? x sin) (lambda (x x-acute) (cons (sin x) (* (cos x) x-acute))))
  ((equal? x cos)
   (lambda (x x-acute) (cons (cos x) (- 0 (* (sin x) x-acute)))))
  ((equal? x atan)
   (lambda ((cons x1 x1-acute) (cons x2 x2-acute))
    (cons (atan x2 x1)
	  (/ (- (* x1 x2-acute) (* x2 x1-acute)) (+ (* x1 x1) (* x2 x2))))))
  ((equal? x =) (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (= x1 x2)))
  ((equal? x <) (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (< x1 x2)))
  ((equal? x >) (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (> x1 x2)))
  ((equal? x <=) (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (<= x1 x2)))
  ((equal? x >=) (lambda ((cons x1 x1-acute) (cons x2 x2-acute)) (>= x1 x2)))
  ((equal? x zero?) (lambda (x x-acute) (zero? x)))
  ((equal? x positive?) (lambda (x x-acute) (positive? x)))
  ((equal? x negative?) (lambda (x x-acute) (negative? x)))
  ((equal? x null?) null?)
  ((equal? x boolean?) boolean?)
  ((equal? x real?) (lambda (x) (and (pair? x) (real? (car x)))))
  ((equal? x pair?) (lambda (x) (and (pair? x) (not (real? (car x))))))
  ((equal? x procedure?) procedure?)
  ((equal? x car) car)
  ((equal? x cdr) cdr)
  ((equal? x cons-procedure) cons-procedure)
  ((equal? x if-procedure) if-procedure)
  ((equal? x equal?) equal?)
  ((equal? x zero) zero)
  ((equal? x plus) plus)
  ((equal? x map-closure-forward) map-closure-forward)
  ((equal? x map-closure-reverse) map-closure-reverse)
  ((equal? x write) write)
  (else (map-closure-forward j* x))))

(define (*j x)
 (cond
  ((null? x) x)
  ((boolean? x) x)
  ((real? x) x)
  ((pair? x) (cons (*j (car x)) (*j (cdr x))))
  ((equal? x +)
   (letrec ((self (lambda (x1 x2)
		   (cons (+ x1 x2)
			 (lambda (y-grave)
			  (cons (zero self) (cons y-grave y-grave)))))))
    self))
  ((equal? x -)
   (letrec ((self (lambda (x1 x2)
		   (cons (- x1 x2)
			 (lambda (y-grave)
			  (cons (zero self) (cons y-grave (- 0 y-grave))))))))
    self))
  ((equal? x *)
   (letrec ((self
	     (lambda (x1 x2)
	      (cons
	       (* x1 x2)
	       (lambda (y-grave)
		(cons (zero self) (cons (* x2 y-grave) (* x1 y-grave))))))))
    self))
  ((equal? x /)
   (letrec ((self (lambda (x1 x2)
		   (cons (/ x1 x2)
			 (lambda (y-grave)
			  (cons (zero self)
				(cons (/ y-grave x2)
				      (- 0 (/ (* x1 y-grave) (* x2 x2))))))))))
    self))
  ((equal? x sqrt)
   (letrec ((self (lambda (x)
		   (cons (sqrt x)
			 (lambda (y-grave)
			  (cons (zero self) (/ y-grave (* 2 (sqrt x)))))))))
    self))
  ((equal? x exp)
   (letrec ((self (lambda (x)
		   (cons (exp x)
			 (lambda (y-grave)
			  (cons (zero self) (* (exp x) y-grave)))))))
    self))
  ((equal? x log)
   (letrec ((self
	     (lambda (x)
	      (cons (log x)
		    (lambda (y-grave) (cons (zero self) (/ y-grave x)))))))
    self))
  ((equal? x sin)
   (letrec ((self (lambda (x)
		   (cons (sin x)
			 (lambda (y-grave)
			  (cons (zero self) (* (cos x) y-grave)))))))
    self))
  ((equal? x cos)
   (letrec ((self (lambda (x)
		   (cons (cos x)
			 (lambda (y-grave)
			  (cons (zero self) (- 0 (* (sin x) y-grave))))))))
    self))
  ((equal? x atan)
   (letrec ((self
	     (lambda (x1 x2)
	      (cons
	       (atan x2 x1)
	       (lambda (y-grave)
		(cons (zero self)
		      (cons (- 0 (/ (* x2 y-grave) (+ (* x1 x1) (* x2 x2))))
			    (/ (* x1 y-grave) (+ (* x1 x1) (* x2 x2))))))))))
    self))
  ((equal? x =)
   (letrec ((self (lambda (x1 x2)
		   (cons (= x1 x2)
			 (lambda (y-grave)
			  (cons (zero self) (cons (zero x1) (zero x2))))))))
    self))
  ((equal? x <)
   (letrec ((self (lambda (x1 x2)
		   (cons (< x1 x2)
			 (lambda (y-grave)
			  (cons (zero self) (cons (zero x1) (zero x2))))))))
    self))
  ((equal? x >)
   (letrec ((self (lambda (x1 x2)
		   (cons (> x1 x2)
			 (lambda (y-grave)
			  (cons (zero self) (cons (zero x1) (zero x2))))))))
    self))
  ((equal? x <=)
   (letrec ((self (lambda (x1 x2)
		   (cons (<= x1 x2)
			 (lambda (y-grave)
			  (cons (zero self) (cons (zero x1) (zero x2))))))))
    self))
  ((equal? x >=)
   (letrec ((self (lambda (x1 x2)
		   (cons (>= x1 x2)
			 (lambda (y-grave)
			  (cons (zero self) (cons (zero x1) (zero x2))))))))
    self))
  ((equal? x zero?)
   (letrec ((self (lambda (x)
		   (cons (zero? x)
			 (lambda (y-grave) (cons (zero self) (zero x)))))))
    self))
  ((equal? x positive?)
   (letrec ((self (lambda (x)
		   (cons (positive? x)
			 (lambda (y-grave) (cons (zero self) (zero x)))))))
    self))
  ((equal? x negative?)
   (letrec ((self (lambda (x)
		   (cons (negative? x)
			 (lambda (y-grave) (cons (zero self) (zero x)))))))
    self))
  ((equal? x null?)
   (letrec ((self (lambda (x)
		   (cons (null? x)
			 (lambda (y-grave) (cons (zero self) (zero x)))))))
    self))
  ((equal? x boolean?)
   (letrec ((self (lambda (x)
		   (cons (boolean? x)
			 (lambda (y-grave) (cons (zero self) (zero x)))))))
    self))
  ((equal? x real?)
   (letrec ((self (lambda (x)
		   (cons (real? x)
			 (lambda (y-grave) (cons (zero self) (zero x)))))))
    self))
  ((equal? x pair?)
   (letrec ((self (lambda (x)
		   (cons (pair? x)
			 (lambda (y-grave) (cons (zero self) (zero x)))))))
    self))
  ((equal? x procedure?)
   (letrec ((self (lambda (x)
		   (cons (procedure? x)
			 (lambda (y-grave) (cons (zero self) (zero x)))))))
    self))
  ((equal? x car)
   (letrec ((self (lambda (x1 x2)
		   (cons x1
			 (lambda (x1-grave)
			  (cons (zero self) (cons x1-grave (zero x2))))))))
    self))
  ((equal? x cdr)
   (letrec ((self (lambda (x1 x2)
		   (cons x2
			 (lambda (x2-grave)
			  (cons (zero self) (cons (zero x1) x2-grave)))))))
    self))
  ((equal? x cons-procedure)
   (letrec ((self
	     (lambda (x1)
	      (cons (letrec ((self
			      (lambda (x2)
			       (cons (cons x1 x2)
				     (lambda (x1-grave x2-grave)
				      (cons (cons x1-grave (cdr (zero self)))
					    x2-grave))))))
		     self)
		    (lambda (x1-grave rest) (cons (zero self) x1-grave))))))
    self))
  ((equal? x if-procedure)
   (letrec ((self
	     (lambda (x1 x2 x3)
	      (if-procedure
	       x1
	       (cons x2
		     (lambda (x2-grave)
		      (cons (zero self) (cons* (zero x1) x2-grave (zero x3)))))
	       (cons
		x3
		(lambda (x3-grave)
		 (cons (zero self) (cons* (zero x1) (zero x2) x3-grave))))))))
    self))
  ((equal? x equal?)
   (letrec ((self (lambda (x1 x2)
		   (cons (equal? x1 x2)
			 (lambda (y-grave)
			  (cons (zero self) (cons (zero x1) (zero x2))))))))
    self))
  ((equal? x zero)
   (letrec ((self
	     (lambda (x)
	      (cons (zero x) (lambda (y-grave) (cons (zero self) (zero x)))))))
    self))
  ((equal? x plus)
   (letrec ((self (lambda (x1 x2)
		   (cons (plus x1 x2)
			 (lambda (y-grave)
			  (cons (zero self) (cons y-grave y-grave)))))))
    self))
  ;; needs work
  ((equal? x map-closure-forward)
   (letrec ((self (lambda (x1 x2)
		   (cons (map-closure-forward x1 x2)
			 (lambda (y-grave)
			  (cons (zero self) (cons (zero x1) (zero x2))))))))
    self))
  ;; needs work
  ((equal? x map-closure-reverse)
   (letrec ((self (lambda (x1 x2)
		   (cons (map-closure-reverse x1 x2)
			 (lambda (y-grave)
			  (cons (zero self) (cons (zero x1) (zero x2))))))))
    self))
  ((equal? x write)
   (letrec ((self
	     (lambda (x)
	      (cons (write x)
		    (lambda (y-grave) (cons (zero self) (write y-grave)))))))
    self))
  (else (map-closure-reverse *j x))))
