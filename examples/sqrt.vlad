(include "j")

(define (abs x) (if (negative? x) (- 0 x) x))

(define (ungenericize x x-grave)
 (cond ((generic-zero? x-grave)
	(cond ((null? x) '())
	      ((boolean? x) '())
	      ((real? x) 0)
	      ((pair? x) (cons (ungenericize (car x) (car x-grave))
			       (ungenericize (cdr x) (cdr x-grave))))
	      ;; procedure: technically this is wrong because it doesn't return
	      ;;            zeros of the free variables
	      (else '())))
       ((pair? x-grave) (cons (ungenericize (car x) (car x-grave))
			      (ungenericize (cdr x) (cdr x-grave))))
       (else x-grave)))

(define (derivative-using-j* f)
 (let ((f-j* (j* f))) (lambda (x) (cdr (f-j* x 1)))))

(define (derivative-using-*j f)
 (let ((f-*j (*j f))) (lambda (x) (ungenericize x (cdr ((cdr (f-*j x)) 1))))))

(define (nr-sqrt x)
 (letrec ((loop (lambda (y)
		 (let ((y-prime (- y (/ (- (* y y) x) (+ y y)))))
		  (if (<= (abs (- y y-prime)) 1e-5)
		      y
		      (loop y-prime))))))
  (loop 1)))

(sqrt 4)

(nr-sqrt 4)

((derivative-using-j* sqrt) 4)

((derivative-using-*j sqrt) 4)

((derivative-using-j* nr-sqrt) 4)

((derivative-using-*j nr-sqrt) 4)
