(include "j")

(define (identity x) x)

(define (abs x) (if (negative? x) (- 0 x) x))

(define (sqr x) (* x x))

(define (derivative-using-j* f) (lambda (x) (cdr ((j* f) x 1))))

(define (derivative-using-*j f) (lambda (x) ((cdr ((*j f) x identity)) 1)))

(define (derivative f) (derivative-using-*j f))

(define (root f x epsilon)
 (let ((x-prime (- x (/ (f x) ((derivative f) x)))))
  (if (<= (abs (- x x-prime)) epsilon)
      x
      (root f x-prime epsilon))))

;;; needs work: To rule out maxima and inflection points.
(define (argmin f x epsilon) (root (derivative f) x epsilon))

;;; needs work: To rule out minima and inflection points.
(define (argmax f x epsilon) (root (derivative f) x epsilon))

(define (invert f) (lambda (y) (root (lambda (x) (abs (- (f x) y))) 1 1e-5)))

;;; An n-dimensional vector with x in position i and zeros elsewhere.
(define (ex x i n)
 (if (zero? n) '() (cons (if (zero? i) x 0) (ex x (- i 1) (- n 1)))))

;;; The ith n-dimensional basis vector.
(define (e i n) (ex 1 i n))

(define (first x) (car x))

(define (rest x) (cdr x))

(define (append x y) (if (null? x) y (cons (first x) (append (rest x) y))))

(define (map-n f n)
 ;; needs work: To use list.
 (if (zero? n) '() (append (map-n f (- n 1)) (cons (f (- n 1)) '()))))

;;; The nxn identity matrix.
(define (i n) (map-n (lambda (i) (e i n)) n))

(define (map f l) (if (null? l) '() (cons (f (first l)) (map f (rest l)))))

;;; needs work: To merge with map.
(define (map2 f l1 l2)
 (if (null? l1)
     '()
     (cons (f (first l1) (first l2)) (map2 f (rest l1) (rest l2)))))

(define (forward-conjoint primal adjoint)
 (if (null? primal)
     (cons '() '())
     (cons (cons (first primal) (first adjoint))
	   (forward-conjoint (rest primal) (rest adjoint)))))

(define (reverse-conjoint primal adjoint)
 (if (null? primal)
     (cons '() (lambda (y-grave) #f))
     (cons (cons (first primal) (first adjoint))
	   (reverse-conjoint (rest primal) (rest adjoint)))))

(define (reduce f i)
 (lambda (l) (if (null? l) i (f (first l) ((reduce f i) (rest l))))))

(define (length l) (if (null? l) 0 (+ (length (rest l)) 1)))

(define (gradient-using-j* f)
 (lambda (x)
  (let ((n (length x)))
   (map-n (lambda (i) (cdr ((j* f) (forward-conjoint x (e i n))))) n))))

(define (gradient-using-*j f)
 (lambda (x)
  (let ((n (length x)))
   ((cdr ((*j f)
	  (reverse-conjoint
	   x (map-n (lambda (i) (lambda (y-grave) (ex y-grave i n))) n))))
    1))))

(define (gradient f) (gradient-using-*j f))

(define (v+ u v) (map2 + u v))

(define (k*v k v) (map (lambda (x) (* k x)) v))

(define (magnitude-squared x) ((reduce + 0) (map sqr x)))

(define (magnitude x) (sqrt (magnitude-squared x)))

(define (gradient-descent f x epsilon)
 (let ((g ((gradient f) x)))
  (if (<= (magnitude g) epsilon)
      x
      (gradient-descent
       f
       (v+ x (k*v (argmin (lambda (k) (f (v+ x (k*v k g)))) 0 epsilon) g))
       epsilon))))
