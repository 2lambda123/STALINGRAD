(include "math")

(define (list-ref l i) (if (zero? i) (first l) (list-ref (rest l) (- i 1))))

(define (transpose a)
 (let ((m (length a)) (n (length (first a))))
  (map-n (lambda (j) (map-n (lambda (i) (list-ref (list-ref a i) j)) m)) n)))

(define (jacobian-using-j* f)
 (let ((f-j* (j* f)))
  (lambda (x)
   (let ((n (length x))) (map-n (lambda (i) (cdr (f-j* x (e i n)))) n)))))

(define (jacobian-using-*j f)
 (let ((f-*j (*j f)))
  (lambda (x)
   (let ((n (length x))
	 (y-tilde
	  (cdr
	   (f-*j x (lambda (x-grave rho) (accumulate (key x) x-grave rho))))))
    (transpose
     (map-n (lambda (i)
	     (car (lookup-delete
		   (key x) (y-tilde (add (key x) (cons (e i n) '()) x)))))
	    n))))))

(define (jacobian f) (jacobian-using-j* f))

(define (j-transpose*v f)
 (let ((f-*j (*j f)))
  (lambda (x y-grave)
   (car
    (lookup-delete
     (key x)
     ((cdr (f-*j x (lambda (x-grave rho) (accumulate (key x) x-grave rho))))
      (add (key x) (cons y-grave '()) x)))))))

(define (prefix l)
 (letrec ((loop (lambda (a l)
		 (if (null? l)
		     '()
		     (let ((a (+ a (first l)))) (cons a (loop a (rest l))))))))
  (loop 0 l)))

((jacobian-using-j* prefix) '(0 1 2 3 4))
((jacobian-using-*j prefix) '(0 1 2 3 4))
((j-transpose*v prefix) '(0 1 2 3 4) '(0 0 0 0 1))
