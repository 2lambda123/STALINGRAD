(include "math")

(define (max x y) (if (> x y) x y))

(define (mnbrak f ax bx k)
 (let ((gold 1.61803399)
       (glimit 100.0)
       (tiny 1.0e-20)
       (sign (lambda (x y) (if (< y 0.0) (- 0.0 x) x))))
  (letrec ((loop
	    (lambda (ax fa bx fb cx fc)
	     (if (< fb fc)
		 (k ax fa bx fb cx fc)
		 (let* ((r (* (- bx ax) (- fb fc)))
			(q (* (- bx cx) (- fb fa)))
			(ux
			 (-
			  bx
			  (/ (- (* (- bx cx) q) (* (- bx ax) r))
			     (* (sign (max (abs (- q r)) tiny) (- q r)) 2.0))))
			(ul (+ bx (* (- cx bx) glimit))))
		  (if (> (* (- bx ux) (- ux cx)) 0.0)
		      (let ((fu (f ux)))
		       (if (< fu fc)
			   (k bx fb ux fu cx fc)
			   (if (> fu fb)
			       (k ax fa bx fb ux fu)
			       (let ((vx (+ cx (* (- cx bx) gold))))
				(loop bx fb cx fc vx (f vx))))))
		      (if (> (* (- cx ux) (- ux ul)) 0.0)
			  (let ((fu (f ux)))
			   (if (< fu fc)
			       (let ((vx (+ ux (* (- ux cx) gold))))
				(loop cx fc ux fu vx (f vx)))
			       (loop bx fb cx fc ux fu)))
			  (if (>= (* (- ux ul) (- ul cx)) 0.0)
			      (loop bx fb cx fc ul (f ul))
			      (let ((vx (+ cx (* (- cx bx) gold))))
			       (loop bx fb cx fc vx (f vx)))))))))))
   (let ((fa (f ax))
	 (fb (f bx)))
    (if (> fb fa)
	(let ((vx (+ ax (* (- ax bx) gold))))
	 (loop bx fb ax fa vx (f vx)))
	(let ((vx (+ bx (* (- bx ax) gold))))
	 (loop ax fa bx fb vx (f vx))))))))

(define (golden f tol ax bx cx k)
 (let* ((gold 1.61803399)
	(r (- gold 1.0))
	(c (- 1.0 r))
	(x1 (if (> (abs (- cx bx)) (abs (- bx ax)))
		bx
		(- bx (* c (- bx ax)))))
	(x2 (if (> (abs (- cx bx)) (abs (- bx ax)))
		(+ bx (* c (- cx bx)))
		bx)))
  (letrec ((loop (lambda (x0 x1 f1 x2 f2 x3)
		  (if (<= (abs (- x3 x0)) (* tol (+ (abs x1) (abs x2))))
		      (if (< f1 f2)
			  (k x1 f1)
			  (k x2 f2))
		      (if (< f2 f1)
			  (let ((xn (+ (* r x2) (* c x3))))
			   (loop x1 x2 f2 xn (f xn) x3))
			  (let ((xn (+ (* r x1) (* c x0))))
			   (loop x0 xn (f xn) x1 f1 x2)))))))
   (loop ax x1 (f x1) x2 (f x2) cx))))

(define (argmin-using-mnbrak-and-golden f l u)
 (mnbrak f l u (lambda (ax fa bx fb cx fc)
		(golden f 1.0e-3 ax bx cx (lambda (mx fm) mx)))))

(define (multivariate-argmin f x epsilon)
 (let ((g (gradient f)))
  (letrec ((loop
	    (lambda (x)
	     (let ((g (g x)))
	      (if (<= (magnitude g) epsilon)
		  x
		  (loop (v+ x
			    (k*v (argmin-using-mnbrak-and-golden
				  (lambda (k) (f (v+ x (k*v k g)))) -100 100)
				 g))))))))
   (loop x))))

(define (multivariate-argmax f x epsilon)
 (multivariate-argmin (lambda (x) (- 0 (f x))) x epsilon))

(define (multivariate-min f x epsilon) (f (multivariate-argmin f x epsilon)))

(define (multivariate-max f x epsilon) (f (multivariate-argmax f x epsilon)))

(let ((epsilon 1e-2)
      (start (list 1 1))
      (f (lambda (x1 y1 x2 y2)
	  (- (+ (sqr x1) (sqr y1)) (+ (sqr x2) (sqr y2))))))
 (let (((list x1 y1)
	(multivariate-argmin
	 (lambda ((list x1 y1))
	  (multivariate-max
	   (lambda ((list x2 y2)) (f x1 y1 x2 y2)) start epsilon))
	 start
	 epsilon)))
  (list (list x1 y1)
	(multivariate-argmax
	 (lambda ((list x2 y2)) (f x1 y1 x2 y2)) start epsilon))))
 ===> ((4.965316230354233e-05 4.965316230354233e-05) (4.965316230354233e-05 4.965316230354233e-05))
