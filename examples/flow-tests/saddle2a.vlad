;;; (include "math")
;;; selections from math.vlad:

;;; General stuff

(define (sqr x) (* x x))

;;; Lists

(define (append x y) (if (null? x) y (cons (car x) (append (cdr x) y))))

(define (length l) (if (null? l) 0 (+ (length (cdr l)) 1)))

;;; Mapping and reduction

(define (map f l) (if (null? l) '() (cons (f (car l)) (map f (cdr l)))))

;;; needs work: To merge with map.
(define (map2 f l1 l2)
 (if (null? l1)
     '()
     (cons (f (car l1) (car l2)) (map2 f (cdr l1) (cdr l2)))))

(define (map-n f n)
 (if (zero? n) '() (append (map-n f (- n 1)) (list (f (- n 1))))))

(define ((reduce f i) l)
 (if (null? l) i (f (car l) ((reduce f i) (cdr l)))))

;;; Vectors

(define (v- u v) (map2 - u v))

(define (k*v k v) (map (lambda (x) (* k x)) v))

(define (magnitude-squared x) ((reduce + 0) (map sqr x)))

(define (magnitude x) (sqrt (magnitude-squared x)))

;;; An n-dimensional vector with x in position i and zeros elsewhere.
(define (ex x i n)
 (if (zero? n) '() (cons (if (zero? i) x 0) (ex x (- i 1) (- n 1)))))

;;; The ith n-dimensional basis vector.
(define (e i n) (ex 1 i n))

;;; Derivatives

(define (gradient-using-j* f)
 (let ((f-forward (j* f)))
  (lambda (x)
   (let ((n (length x)))
    (map-n (lambda (i) (tangent (f-forward (bundle x (e i n))))) n)))))

;;; saddle.vlad:

(define (distance-squared u v) (magnitude-squared (v- v u)))

(define (distance u v) (sqrt (distance-squared u v)))

(define (multivariate-argmin f x)
 (let ((g (gradient-using-j* f))
       (side (write 0)))
  (letrec ((loop
	    (lambda (x fx gx eta i)
	     (cond ((<= (magnitude gx) 1.0e-0) x)
		   ((= i 10) (loop x fx gx (* 2.0 eta) 0))
		   (else
		    (let ((x-prime (v- x (k*v eta gx))))
		     (if (<= (distance x x-prime) 1.0e-0)
			 x
			 (let ((fx-prime (f x-prime)))
			  (if (< fx-prime fx)
			      (loop x-prime fx-prime (g x-prime) eta (+ i 1))
			      (loop x fx gx (/ eta 2.0) 0))))))))))
   (loop x (f x) (g x) 1.0e-0 0))))

(define (multivariate-argmax f x)
 (multivariate-argmin (lambda (x) (- 0.0 (f x))) x))

(define (multivariate-min f x) (f (multivariate-argmin f x)))

(define (multivariate-max f x) (f (multivariate-argmax f x)))

(let ((start (list (read-real) (read-real)))
      (f (lambda (x1 y1 x2 y2)
	  (- (+ (sqr x1) (sqr y1)) (+ (sqr x2) (sqr y2))))))
 (let (((list x1 y1)
	(multivariate-argmin
	 (lambda ((list x1 y1))
	  (multivariate-max (lambda ((list x2 y2)) (f x1 y1 x2 y2)) start))
	 start)))
  (list (list x1 y1)
	(multivariate-argmax (lambda ((list x2 y2)) (f x1 y1 x2 y2)) start))))
