(define (length l) (if (null? l) 0 (+ (length (cdr l)) 1)))

(define ((map f) l) (if (null? l) '() (cons (f (car l)) ((map f) (cdr l)))))

(define ((map2 f) l1 l2)
 (if (null? l1) '() (cons (f (car l1) (car l2)) ((map2 f) (cdr l1) (cdr l2)))))

(define ((map-n f) n)
 (letrec ((loop (lambda (n c)
                 (if (zero? n) c (loop (- n 1) (cons (f (- n 1)) c))))))
  (loop n '())))

(define ((reduce f i) l) (if (null? l) i (f (car l) ((reduce f i) (cdr l)))))

(define (dot u v) ((reduce + 0) ((map2 *) u v)))

(define (v- u v) ((map2 -) u v))

(define (k*v k v) ((map (lambda (x) (* k x))) v))

(define (magnitude-squared v) (dot v v))

(define (magnitude x) (sqrt (magnitude-squared x)))

(define (distance-squared u v) (magnitude-squared (v- v u)))

(define (distance u v) (sqrt (distance-squared u v)))

;;; An n-dimensional vector with x in position i and zeros elsewhere.
(define (ex x i n)
 (if (zero? n) '() (cons (if (zero? i) x 0) (ex x (- i 1) (- n 1)))))

;;; The ith n-dimensional basis vector.
(define (e i n) (ex 1 i n))

(define (gradient-using-j* f)
 (let ((f-forward (j* f)))
  (lambda (x)
   (let ((n (length x)))
    ((map-n (lambda (i) (tangent (f-forward (bundle x (e i n)))))) n)))))

(define (naive-gradient-descent f x epsilon)
 (let ((g (gradient-using-j* f)))
  (letrec ((loop
            (lambda (x fx gx eta i)
             (cond ((<= (magnitude gx) 1.0e-0) x)
                   ((= i 10) (loop x fx gx (* 2.0 eta) 0))
                   (else
                    (let ((x-prime (v- x (k*v eta gx))))
                     (if (<= (distance x x-prime) 1.0e-0)
                         x
                         (let ((fx-prime (f x-prime)))
                          (if (< fx-prime fx)
                              (loop x-prime fx-prime (g x-prime) eta (+ i 1))
                              (loop x fx gx (/ eta 2.0) 0))))))))))
   (loop x (f x) (g x) epsilon 0))))

(naive-gradient-descent
 (lambda ((list x y)) (+ (* x x) (* y y))) (list 1.0 1.0) 1.0e-0)
