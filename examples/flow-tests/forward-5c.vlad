;;;(include "math")

(define (sqr x) (* x x))

(define (append x y) (if (null? x) y (cons (car x) (append (cdr x) y))))

(define (length l) (if (null? l) 0 (+ (length (cdr l)) 1)))

(define (map f l) (if (null? l) '() (cons (f (car l)) (map f (cdr l)))))

(define (map2 f l1 l2)
 (if (null? l1)
     '()
     (cons (f (car l1) (car l2)) (map2 f (cdr l1) (cdr l2)))))

(define (map-n f n)
 (if (zero? n) '() (append (map-n f (- n 1)) (list (f (- n 1))))))

(define ((reduce f i) l)
 (if (null? l) i (f (car l) ((reduce f i) (cdr l)))))

(define (dot u v) ((reduce + 0) (map2 * u v)))

(define (m*v a v) (map (lambda (u) (dot u v)) a))

;;; An n-dimensional vector with x in position i and zeros elsewhere.
(define (ex x i n)
 (if (zero? n) '() (cons (if (zero? i) x 0) (ex x (- i 1) (- n 1)))))

;;; The ith n-dimensional basis vector.
(define (e i n) (ex 1 i n))

(define ((partial-derivative-using-j* f i) x)
 (tangent ((j* f) (bundle x (e i (length x))))))

(define (partial-derivative f i) (partial-derivative-using-j* f i))

(define ((hessian-using-j*-j* f) x)
 (let ((n (length x)))
  (map-n (lambda (i)
	  (map-n (lambda (j)
		  ((partial-derivative-using-j*
		    (partial-derivative-using-j* f i) j)
		   x))
		 n))
	 n)))

(define (hessian f) (hessian-using-j*-j* f))

(define (hessian-quadratic-form-using-j*-j* f x u v)
 (let ((f-forward (j* f)))
  (tangent ((j* (lambda (x) (tangent (f-forward (bundle x v)))))
	    (bundle x u)))))

(define (hessian-quadratic-form f x v)
 (hessian-quadratic-form-using-j*-j* f x v))


(define (alternate-hessian-quadratic-form f x u v)
 (dot u (m*v ((hessian f) x) v)))

(define (curried-hessian-quadratic-form f)
 (let ((f-forward-forward (j* (j* f))))
  (lambda (x u v)
   (tangent (tangent (f-forward-forward
		      (bundle (bundle x u) (bundle v (zero x)))))))))

(define (f (list x y)) (+ (* 2 (sqr x)) (+ (* 3 (* x y)) (* 4 (sqr y)))))

(hessian-quadratic-form-using-j*-j* f '(3 4) '(7 8) '(9 10))
