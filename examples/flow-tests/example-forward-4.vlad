(define (append x y) (if (null? x) y (cons (car x) (append (cdr x) y))))

(define (length l) (if (null? l) 0 (+ (length (cdr l)) 1)))

(define (abs x) (if (negative? x) (- 0 x) x))

(define (map f l) (if (null? l) '() (cons (f (car l)) (map f (cdr l)))))

(define (map2 f l1 l2)
 (if (null? l1)
     '()
     (cons (f (car l1) (car l2)) (map2 f (cdr l1) (cdr l2)))))

(define (map-n f n)
 (if (zero? n) '() (append (map-n f (- n 1)) (list (f (- n 1))))))

(define ((reduce f i) l)
 (if (null? l) i (f (car l) ((reduce f i) (cdr l)))))

(define (dot u v) ((reduce + 0) (map2 * u v)))

(define (v+ u v) (map2 + u v))

(define (k*v k v) (map (lambda (x) (* k x)) v))

(define (magnitude-squared v) (dot v v))

(define (magnitude v) (sqrt (magnitude-squared v)))

;;; An n-dimensional vector with x in position i and zeros elsewhere.
(define (ex x i n)
 (if (zero? n) '() (cons (if (zero? i) x 0) (ex x (- i 1) (- n 1)))))

;;; The ith n-dimensional basis vector.
(define (e i n) (ex 1 i n))

(define (derivative-using-j* f)
 (let ((f-forward (j* f))) (lambda (x) (tangent (f-forward (bundle x 1))))))

(define (gradient-using-j* f)
 (let ((f-forward (j* f)))
  (lambda (x)
   (let ((n (length x)))
    (map-n (lambda (i) (tangent (f-forward (bundle x (e i n))))) n)))))

(define (root f x epsilon)
 (let ((x-prime (- x (/ (f x) ((derivative-using-j* f) x)))))
  (if (<= (abs (- x x-prime)) epsilon) x (root f x-prime epsilon))))

(define (argmin f x epsilon) (root (derivative-using-j* f) x epsilon))

(define (gradient-descent f x epsilon)
 (let ((g ((gradient-using-j* f) x)))
  (if (<= (magnitude g) epsilon)
      x
      (gradient-descent
       f
       (v+ x (k*v (argmin (lambda (k) (f (v+ x (k*v k g)))) 0 epsilon) g))
       epsilon))))

(gradient-descent magnitude-squared (list 3 4) 1e-5)
