(include "j")

(define (identity x) x)

(define (not x) (if x #f #t))

(define (abs x) (if (negative? x) (- 0 x) x))

(define (sqr x) (* x x))

(define (derivative-using-j* f)
 (let ((f-j* (j* f))) (lambda (x) (cdr (f-j* x 1)))))

(define (derivative-using-*j f)
 (let ((f-*j (*j f)))
  (lambda (x)
   (car (exit (key x)
	      ((cdr (f-*j
		     cdr
		     x
		     (lambda (x-grave rho) (accumulate (key x) rho x-grave))))
	       1 (add (key x) '() x)))))))

(define (derivative f) (derivative-using-*j f))

(define (root f x epsilon)
 (let ((f-prime (derivative f)))
  (letrec ((loop (lambda (x)
		  (let ((x-prime (- x (/ (f x) (f-prime x)))))
		   (if (<= (abs (- x x-prime)) epsilon)
		       x
		       (loop x-prime))))))
   (loop x))))

;;; needs work: To rule out maxima and inflection points.
(define (argmin f x epsilon) (root (derivative f) x epsilon))

;;; needs work: To rule out minima and inflection points.
(define (argmax f x epsilon) (root (derivative f) x epsilon))

(define (invert f) (lambda (y) (root (lambda (x) (abs (- (f x) y))) 1 1e-5)))

;;; An n-dimensional vector with x in position i and zeros elsewhere.
(define (ex x i n)
 (letrec ((loop (lambda (i n)
		 (if (zero? n)
		     '()
		     (cons (if (zero? i) x 0) (loop  (- i 1) (- n 1)))))))
  (loop i n)))

;;; The ith n-dimensional basis vector.
(define (e i n) (ex 1 i n))

(define (first x) (car x))

(define (rest x) (cdr x))

(define (append x y)
 (letrec ((loop
	   (lambda (x) (if (null? x) y (cons (first x) (loop (rest x)))))))
  (loop x)))

(define (map-n f n)
 (letrec ((loop
	   (lambda (n)
	    (if (zero? n) '() (append (loop (- n 1)) (list (f (- n 1))))))))
  (loop n)))

;;; The nxn identity matrix.
(define (i n) (map-n (lambda (i) (e i n)) n))

(define (map f l)
 (letrec ((loop (lambda (l)
		 (if (null? l) '() (cons (f (first l)) (loop (rest l)))))))
  (loop l)))

;;; needs work: To merge with map.
(define (map2 f l1 l2)
 (letrec ((loop (lambda (l1 l2)
		 (if (null? l1)
		     '()
		     (cons (f (first l1) (first l2))
			   (loop (rest l1) (rest l2)))))))
  (loop l1 l2)))

(define (reduce f i)
 (letrec ((loop (lambda (l) (if (null? l) i (f (first l) (loop (rest l)))))))
  loop))

(define (length l) (if (null? l) 0 (+ (length (rest l)) 1)))

(define (gradient-using-j* f)
 (let ((f-j* (j* f)))
  (lambda (x)
   (let ((n (length x))) (map-n (lambda (i) (cdr (f-j* x (e i n)))) n)))))

(define (gradient-using-*j f) (derivative-using-*j f))

(define (gradient f) (gradient-using-*j f))

(define (v+ u v) (map2 + u v))

(define (k*v k v) (map (lambda (x) (* k x)) v))

(define (magnitude-squared x) ((reduce + 0) (map sqr x)))

(define (magnitude x) (sqrt (magnitude-squared x)))

(define (gradient-descent f x epsilon)
 (let* ((del-f (gradient f))
	(line (lambda (x g k) (f (v+ x (k*v k g)))))
	(line-j* (j* line))
	(line-prime (lambda (x g k)
		     (cdr (line-j* (cons x (cons g k))
				   (cons (zero x) (cons (zero g) 1))))))
	(line-prime-j* (j* line-prime))
	(line-prime-prime
	 (lambda (x g k)
	  (cdr (line-prime-j* (cons x (cons g k))
			      (cons (zero x) (cons (zero g) 1)))))))
  (letrec ((loop
	    (lambda (x)
	     (let ((g (del-f x)))
	      (letrec ((argmin (lambda (k)
				(let ((k-prime
				       (- k (/ (line-prime x g k)
					       (line-prime-prime x g k)))))
				 (if (<= (abs (- k k-prime)) epsilon)
				     k
				     (argmin k-prime))))))
	       (if (<= (magnitude g) epsilon)
		   x
		   (loop (v+ x (k*v (argmin 0) g)))))))))
   (loop x))))
