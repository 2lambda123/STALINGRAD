\input texinfo @c -*-texinfo-*-
@comment %**start of header
@setfilename manual
@settitle VLAD Programmer Manual
@comment %**end of header

@setchapternewpage off
@macro todo{text}
@strong{TODO: \text\}
@end macro

@contents

@ifnottex
@node Top
@top VLAD Programmer Manual

@end ifnottex

@menu
* Overview::
* Getting Started::
* Scheme Stuff::
* Numeric Basis::
* Input and Output::
* Introducing Imprecision::
* Forward AD::
* Reverse AD::
@end menu

@node Overview
@chapter Overview

VLAD is a functional language with a first-class automatic
differentiation operator and an aggressively optimizing compiler.  The
purpose of VLAD is to push the envelope on the speed of numeric
computing, without sacrificing any essential expressive power; and to
dispel any myths that automatic differentiation needs to be hard to
use or slow to execute.

VLAD is essentially a subset of Scheme, augmented with functions for
doing automatic differentiation, and implemented with a compiler that
does very aggressive optimizations.  In particular, VLAD shares
Scheme's simple syntax and overall execution model.  The most striking
differences are the automatic differentiation, destructuring of
procedure arguments, and how fast programs go once you've compiled
them.  VLAD is designed to compile to efficient code without
sacrificing any essential expressive power.  Being a research
prototype, however, VLAD sacrifices various uninteresting
conveniences, which are left to user-space libraries and to later
incarnations of these language design ideas.

@node Getting Started
@chapter Getting Started

A VLAD program is notionally just a single expression.  For example,

@lisp
(+ 3 4)
@end lisp
@noindent
is a perfectly good VLAD program whose result is @code{7}.  The
Stalingrad program reads a file containing a VLAD expression, compiles
that expression, evaluates it, and prints the result.

As a syntactic convenience, helper procedures can be defined using
@code{define}.  Also, Stalingrad will treat multiple non-definition
expressions in a single source file as multiple ``programs'', and
compile and execute all of them in turn.  The scope of definitions
introduced with define is the entire contiguous block of definitions
in which that define appears, and all subsequent expressions.

For example,

@lisp
(define (double-loop)
  (let* ((x (read-real))
         (y (write (* 3 x))))
    (double-loop)))

(double-loop)
@end lisp
@noindent
is a VLAD program that will read real numbers from standrad input
write their triples to standard output.

VLAD has the following support for multifile programs: If you have a
file of definitions named @var{filename}, you can use those
definitions in another program by writing @code{(include
"@var{filename}")} as a toplevel form in that program.  This mechanism
works recursively.

You can use Stalingrad to compile but not run a VLAD program by
passing it the @code{--compile} option.  If the program was in file
@file{foo.vlad}, Stalingrad will emit the binary into the file
@file{foo}, which you can then execute.  Stalingrad also has many other
options and modes for controlling the compilation process, emitting
various partial results thereof, etc.

@node Scheme Stuff
@chapter Scheme Stuff

The basic structure of VLAD code is inherited from Scheme.
Identifiers are whitespace-delimited.  Expressions are written in
fully-parenthesized prefix notation.  Comments begin with a semicolon
character (@code{;}) and last until the end of the line.  
@todo Does VLAD support expression comments with #; and/or block comments with #| |#?
Variables are lexically scoped.  Objects have unlimited extent.

The basic evaluation model of VLAD is also inherited from Scheme.  The
first subexpression of an expression determines how that expression
will be evaluated---if it's an identifier naming a special form,
then the whole form will be evaluated that way; otherwise, the first
subform will be evaluated, treated as a procedure, and applied to the
evaluated values of the remaining subforms.

The main difference between Scheme and VLAD at this level is that VLAD
has automatic destructuring of bound values.  That is, if the procedure
made by
@example
(lambda (cons x y) ...)
@end example
@noindent
is passed a pair, then in the body of this procedure @code{x} and
@code{y} will be bound to the car and cdr of that pair, respectively.
Dually, when a procedure is passed syntactically multiple arguments,
as with passing the procedure @code{foo} the three arguments
@code{bar}, @code{baz}, and @code{quux},

@example
(foo bar baz quux)
@end example
@noindent
the three arguments are implicitly collected into a structure with
@code{cons*} and passed to the procedure as a single argument.
Presumably, the procedure will destructure that structure to get the
pieces; for example, if @code{foo} were defined with
@example
(lambda (bar baz quux) ...)
@end example
@noindent
that actually represents a destructuring operation.  All this notional
structuring and destructuring is dealt with at compile time (see
"Performance Model") and incurs no runtime overhead.  See
"Destructuring" for the detailed rules.

@todo Detailed lexical syntax of VLAD, differences from Scheme

@todo Destructuring

@todo Performance Model

@menu
* Literals::
* Special forms::
* Procedures::
@end menu

@node Literals
@section Literals

@defvr Literal #t
@defvrx Literal #f
Literal syntax for booleans: like Scheme.
@end defvr

Literal syntax for numbers is also like Scheme, except that all
numerals are interpreted as constant IEEE-64 floating point numbers,
because the only numbers in VLAD are IEEE-64 floating point.

@todo () ?

@node Special forms
@section Special forms

VLAD supports the following special forms.  They are like the
corresponding Scheme special forms, except for some differences
pointed out with each one:

@defspec lambda formalspec expression
Like Scheme, except for destructuring the formal parameters given by
@var{formalspec} (see "Destructuring") and may only have one
@var{expression} in the body.
@end defspec

@defspec define definiendum definiens
Like Scheme, except may only appear at the top level of a program (no
internal defines).  Also, via @code{lambda}, supports destructuring
but does not support multi-expression procedure bodies.
@todo{Are redefinitions of names already defined in the same
define-block acceptable?}
@end defspec

@defspec let bindings@dots{} expression
@defspecx let* bindings@dots{} expression
@defspecx letrec bindings@dots{} expression
Like Scheme except may only have one @var{expression} in the body.
VLAD does not support the ``named let'' Scheme iteration syntax.
@todo Are the destructuring rules different for let, let* and letrec?
@todo Can the initialization forms in letrec not be lambdas?
@end defspec

@defspec cond clauses@dots{}
Like Scheme, except the final @code{else} clause is required, and
the syntaxes
@code{(cond ... (e) ...)} and @code{(cond ... (e1 => e2) ...)}
are not supported.  Also, clause bodies must be one expression.
@end defspec

@defspec if predicate consequent alternate
Like Scheme; VLAD does not support the one-armed @code{if} syntax.
@end defspec

@defspec quote datum
@defspecx and expressions@dots{}
@defspecx or expressions@dots{}
Like Scheme.
@end defspec

TODO quasiquote and unquote?

@defspec cons car cdr
@defspecx cons* items@dots{}
@defspecx list items@dots{}
These do the same thing as in Scheme, except that they are special
forms in VLAD, and so may not be passed as function parameters,
returned from functions, etc.
@end defspec

@node Procedures
@section Procedures

null?
boolean?
pair?
procedure?

These do what you expect.

if-procedure

Normally, you would use the if form, but the procedure version is
provided for completeness.  This is convenient because in VLAD, if is
a macro that expands as
(if p c a)  ==>  (if-procedure p (lambda () c) (lambda () a))
and if-procedure is supplied primitively.  if-procedure does what the
Scheme procedure
(define (if-procedure p c a)
  (if p (c) (a)))
would do.

@node Numeric Basis
@chapter Numeric Basis

The numbers in VLAD are all IEEE-64 floating point.  There is no
provision for integer arithmetic except as a subset of floating point
arithmetic, and there is no distinction between exact and inexact
numbers.

The following subset of the Scheme numeric basis is provided as
primitives:

+
-
*
/
sqrt
exp
log
sin
cos
atan
=
<
>
<=
>=
zero?
positive?
negative?
real?

These agree with standard Scheme semantics, expect for questions of
arity.  No VLAD primitive takes variable numbers of arguments, so all
of the above are either unary or binary, as appropriate.  Notably,
ATAN is binary; and no unary minus is provided.

Numeric constants are written in the standard way.
TODO Does VLAD support radix prefixes?

@node Introducing Imprecision
@chapter Introducing Imprecision

real

At runtime, REAL is the identity function on real numbers.  However,
REAL forces the flow analysis to forget the value of its argument, and
avoid specializing any procedures that use it to its exact value.  See
"Performance Model".  For example, given

(define (fact x)
  (if (= x 0)
      1
      (* x (fact (- x 1)))))

writing

(fact 5)

would cause the flow analysis to unroll the recursion in FACT all the
way, and completely solve the return value of that form (to 120) at
compile time.  This could prove prohibitively expensive.
TODO There are some internal wideners that prevent this absurd behavior;
how do they work?  Are they good enough that REAL is wizard-only now?

In contrast, writing

(fact (real 5))

would cause the flow analysis to produce a FACT procedure that
computes the factorials of (positive integer) real numbers, and
compute the factorial of 5 at runtime.

@node Input and Output
@chapter Input and Output

VLAD provides two I/O primitives:

read-real

Takes no arguments, reads a real number from the standard input, and
returns it.

write

Takes a real number argument, writes it to the standard output, and
returns it.  Since VLAD does not support multiple expressions in
procedure bodies, if you want to write and then do something else,
you should:

(let ((ignore (write foo)))
  do-something-else)

TODO structured WRITE ? What is WRITE-REAL supposed to be?

@node Forward AD
@chapter Forward AD

The modus operandi for forward AD is:

1) Bundle the primal input value with a tangent value (representing
   the direction of a directional derivative), with
   (bundle primal (perturb tangent))

2) Transform the function being differentiated to do the right thing
   with such bundles, with
   (j* f)
   which is a non-primitive procedure definable as
   (define (j* f)
     (bundle f (perturb (zero f))))
   more on this below

3) Push the bundle through the transformed function.

4) Extract from the output the primal value and the derivative along
   that direction with
   (primal bundle) and (unperturb (tangent bundle))

Here are the details of the VLAD procedures that do this:

(perturb object)

Type-tags the given object as being a perturbation.  This may be done
with any VLAD object, but it is most useful with real numbers
directly, or structured objects that contain real numbers inside.

(perturbation? object)

Detects whether the given object is a pertubation constructed with
PERTURB.

(unperturb perturbation)

Strips the perturbation tag off the given perturbation and returns the
underlying object.

(bundle primal perturbation)

Bundles a given primal value and a given perturbation into a
primal-tangent bundle.  The primal and the perturbation have to have
the same shape, differing only in the real numbers they contain.
This is useful for constructing inputs to forward-mode functions.
BUNDLE also operates on functions to transform them to treat bundles
correctly; see below.

(forward? object)

Detects whether the given object is a bundle constructed with BUNDLE.

(primal bundle)

Extracts the primal component of the given bundle.

(tangent bundle)

Extracts the tangent component of the given bundle.  You probably want
to call UNPERTURB on the output of TANGENT.

(zero object)

Constructs an object of the same shape as OBJECT, but with all real
values replaced with zero.


TODO This description is factually correct, but may send the wrong
message.  The reason I wrote it like this is because I haven't thought
through all the math underlying the reasons why BUNDLE behaves the way
it does.  In particular, I am not convinced that the operation BUNDLE
performs on functions is actually the same operation as what it does
to data, and should have the same name.  Nonetheless, this is how the
current code works, and of course this is one of the central features
of VLAD so it better be described in the documentation.

BUNDLE has slightly different behavior on data and on procedures.
BUNDLE operating on procedures is so arranged that the pushforward
operator, namely the operator that transforms a primal function into
one that will operate on bundles and compute derivatives therewith,
can be defined as:

(define (j* f)
  (bundle f (perturb (zero f))))

Given such a j*, one can then write forward-mode differentiation
procedures as follows:

(define (derivative-R->Rn-using-j* f)
  (let ((f-forward (j* f)))
    (lambda (x)
      (unperturb (tangent (f-forward (bundle x (perturb 1))))))))

(define (directional-derivative-using-j* f)
  (let ((f-forward (j* f)))
    (lambda (x dx)
      (unerturb (tangent (f-forward (bundle x (perturb dx))))))))

(define (directional-derivative-via-R->Rn-derivative f)
  (lambda (x dx)
    ((derivative-R->Rn-using-j* (lambda (r) (f (+ x (* r dx))))) 0)))

etc, to taste.

@node Reverse AD
@chapter Reverse AD

The modus operandi for reverse AD is:

1) Tag the primal inputs as things for which sensitivity values are
   desired, with
   (*j primal)

2) Transform the function being differentiated to collect a record of
   the primal computation it does, and to assemble a procedure that
   can use that record to compute sensitivity values in reverse, with
   (*j f)

3) Run the transformed function on the tagged inputs to create that
   procedure (and also the primal answer)

4) Tag a direction in the output space as the initial output
   sensitivity.

5) Apply the reverse procedure to that tagged direction.

6) Untag the resulting sensitivity object to extract the corresponding
   change input direction.

Here are the details of the VLAD procedures that do this:

(*j primal)

Transforms the given primal object into reverse-AD form.  In the case
of data, tags it as being the primal value for a reverse AD
computation.  In the case of functions, transforms them to accept such
data and produce reverse procedures.  The resulting transformed
function, when given a tagged input, will produce a pair of the tagged
primal output and the procedure for computing sensitivities in
reverse.  That procedure, when given a sensitivity corresponding to
the output (and of the same shape), will produce a sensitivity-tagged
pair of the procedure for doing the original primal computation and a
sensitivity corresponding to the input.  The type of *j applied to a
function is:

*j: ((al -> be) -> ((r-tag al) -> (cons (r-tag be) ((sens be) -> (sens (cons (al -> be) al)))))

Also see below.

I can only assume that the procedure for doing the primal computation
is echoed this way out of a sense of symmetry, or else for debugging
purposes.

(*j-inverse reverse-transformed-object)

Undoes the transformation done by *j and returns the original object.

(reverse? object)

Returns whether the given object has been transformed by *j.

(sensitize object)

Returns a sensitivity-tagged version of the given object.

(sensitivity? object)

Detects whether the given object is a sensitivity.

(unsensitize sensitivity)

Strips the sensitivity tag off the given sensitivity object and returns
the underlying object.

(plus object1 object2)

Adds the two given objects pointwise.  They must have the same shape.
(plus object (zero object)) is an identity operation.  This is
important in the interior of the reverse computation, because this is
the reverse transform of the implicit fanout of using the same
variable more than once.  It is, however, also made available to the
user.

Given these primitives, one can write procedures for doing
differentiation in reverse mode such as this:

(define (gradient-Rn->R-using-*j f)
  (let ((f-reverse (*j f)))
    (lambda (x)
      (cdr (unsensitize ((cdr (f-reverse (*j x))) (sensitize 1)))))))

@bye
