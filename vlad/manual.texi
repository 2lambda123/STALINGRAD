\input texinfo @c -*-texinfo-*-
@comment %**start of header
@setfilename manual
@set EDITION 0.3
@set VERSION 0.1
@set UPDATED November 1, 2010
@settitle VLAD Programmer Manual
@comment %**end of header

@syncodeindex vr fn
@allowcodebreaks false
@setchapternewpage off
@macro todo{text}
@strong{TODO: \text\}
@end macro

@c Major TODO: write the Performance Model section
@c Major TODO: mechanically confirm the various assertions in the manual

@macro abstract
VLAD is a functional language with a first-class automatic
differentiation operator and an aggressively optimizing compiler.  The
purpose of VLAD is to push the envelope on the speed of numeric
computing, without sacrificing any essential expressive power; and to
dispel any myths that automatic differentiation needs to be hard to
use or slow to execute.
@end macro

@titlepage
@title VLAD Programmer Manual
@subtitle Edition @value{EDITION} for VLAD version @value{VERSION}
@subtitle @value{UPDATED}
@author Alexey Radul
@page
@center{@strong{Abstract}}
@quotation
@abstract
@end quotation
@end titlepage

@ifnottex
@node Top
@top VLAD Programmer Manual

This manual documents VLAD vesion @value{VERSION}.
This is edition @value{EDITION} of the manual, up to date as of @value{UPDATED}.

@heading Abstract
@abstract
@end ifnottex

@ifnotinfo
@contents
@end ifnotinfo

@menu
* Overview::
* Installation::
* Getting Started::
* Scaffolding::
* Numerics::
* Forward AD::
* Reverse AD::
* Performance::
* Index::
@end menu

@node Overview
@chapter Overview

VLAD is essentially a subset of Scheme, augmented with functions for
doing automatic differentiation, and implemented with a compiler that
does very aggressive optimizations.  In particular, VLAD shares
Scheme's simple syntax and overall execution model.  The most striking
differences are the automatic differentiation, destructuring of
procedure arguments, and how fast programs go once you've compiled
them.  VLAD is designed to compile to efficient code without
sacrificing any essential expressive power.  Being a research
prototype, however, VLAD sacrifices various uninteresting
conveniences, which are left to user-space libraries and to later
incarnations of these language design ideas.

@node Installation
@chapter Installation

Stalingrad is the interpreter and compiler for VLAD.  To install
Stalingrad, you must have access to the Git repositories at
@code{cvs.bcl.hamilton.ie}, and you must have
@code{dpkg-checkbuilddeps} and @code{fakeroot} on your system.  The
latter can be obtained by @code{apt-get install dpkg-dev fakeroot}.  Given
these, installation is a two-step process.

First, install the development version of @code{scheme2c}:

@example
git clone ssh://cvs.bcl.hamilton.ie/home/git/scheme2c.git
cd scheme2c
dpkg-checkbuilddeps
apt-get install @var{anything missing indicated by dpkg-checkbuilddeps}
fakeroot debian/rules binary
sudo dpkg --install ../scheme2c_@var{xxx}.deb
@end example

Then compile Stalingrad proper:

@example
git clone ssh://cvs.bcl.hamilton.ie/home/git/stalingrad.git
cd stalingrad
autoconf
./configure
make
@end example

You should now have a working binary of Stalingrad in
@code{source/stalingrad}, with which you can run VLAD
programs:

@example
source/stalingrad @var{foo}.vlad
@end example

will run the VLAD program in @file{@var{foo}.vlad}.  To compile VLAD
programs, you also need to ensure that you have all the libraries that
VLAD programs are linked against; the only one that is not completely
standard is the Boehm garbage collector, which you can get on Debian
with @code{apt-get install libgc-dev}.  Then

@example
source/stalingrad -compile @var{foo}.vlad
@end example

will compile the VLAD program in @file{@var{foo}.vlad} into an
executable named @file{@var{foo}}.  Stalingrad also has many other
options and modes for controlling the compilation process, emitting
various partial results thereof, etc.

@node Getting Started
@chapter Getting Started

A VLAD program is notionally just a single expression.  For example,

@lisp
(+ 3 4)
@end lisp

@noindent
is a perfectly good VLAD program whose result is @code{7}.  The
Stalingrad program reads a file containing a VLAD expression, compiles
that expression, evaluates it, and prints the result.

As a syntactic convenience, helper procedures can be defined using
@code{define}.  Also, Stalingrad will treat multiple non-definition
expressions in a single source file as multiple ``programs'', and
compile and execute all of them in turn.  The scope of definitions
introduced with define is the entire contiguous block of definitions
in which that define appears, and all subsequent expressions.

For example,

@lisp
(define (double-loop)
  (let* ((x (read-real))
         (y (write (* 3 x))))
    (double-loop)))

(double-loop)
@end lisp

@noindent
is a VLAD program that will read real numbers from standrad input
and write their triples to standard output.

VLAD has the following support for multifile programs: If you have a
file of definitions named @var{filename}, you can use those
definitions in another program by writing @code{(include
"@var{filename}")} as a toplevel form in that program.  This mechanism
works recursively.  The search path where Stalingrad looks for include
files is the working directory, any directories given by @code{-I}
switches when running Stalingrad, and
@file{/usr/local/stalingrad/include/}, in that order.

@node Scaffolding
@chapter Scaffolding

The basic structure of VLAD code is inherited from Scheme.
Identifiers are whitespace-delimited.  Expressions are written in
fully-parenthesized prefix notation.  Comments begin with a semicolon
character (@code{;}) and last until the end of the line.
Variables are lexically scoped.  Objects have unlimited extent.

The basic evaluation model of VLAD is also inherited from Scheme.  The
first subexpression of an expression determines how that expression
will be evaluated---if it's an identifier naming a special form,
then the whole form will be evaluated that way; otherwise, the first
subform will be evaluated, treated as a procedure, and applied to the
evaluated values of the remaining subforms.
The empty expression @code{()} is not legal VLAD.

The main syntactic difference between Scheme and VLAD is that VLAD
has automatic destructuring of bound values.
@xref{Destructuring} for the details, but the gist is that

@example
(let (((cons x y) (cons 1 2)))
  ... x ... y ...)
@end example

@noindent
works and does what you would expect.  This facility is how VLAD
implements multiple formal parameters to a procedure, multiple
arguments passed to a procedure at its call site, and multiple return
values.  All this notional structuring and destructuring is dealt with
at compile time (@pxref{Performance}) and incurs no runtime overhead.

@todo Detailed lexical syntax of VLAD, differences from Scheme

@menu
* Destructuring::
* Literals::
* Special forms::
* Procedures::
* Input and Output::
* Introducing Imprecision::
@end menu

@node Destructuring
@section Destructuring

In VLAD, all procedures take exactly one argument, which they may
implicitly destructure, depending on the formal parameter
specification of the procedure.  Dually, all procedure call sites are
coerced into passing the callee exactly one argument, which is a
structure that contains all the syntactically apparent arguments.

Syntactically multiple procedure arguments are folded into a
destructuring that uses @code{cons*}:

@example
(lambda () @var{e})  @expansion{}  (lambda ((cons*)) @var{e})
(lambda (x) @var{e})  @expansion{}  (lambda (x) @var{e})
(lambda (x y z@dots{}) @var{e})  @expansion{}  (lambda ((cons* x y z@dots{})) @var{e})
@end example

Likewise, syntactically multiple arguments in a procedure call site
are folded into making a structure with @code{cons*}:

@example
(@var{f} ())  @expansion{}  (@var{f} (cons*))
(@var{f} x)  @expansion{}  (@var{f} x)
(@var{f} x y z@dots{})  @expansion{}  (@var{f} (cons* x y z@dots{}))
@end example

In addition to the automatic destructuring introduced by syntactically
multiple formal parameters to a procedure, VLAD supports
user-specified destructuring by writing @code{cons}, @code{cons*}, or
@code{list} forms in the formal parameter spec of a procedure.  For example,

@lisp
((lambda ((cons x y))
   (+ x y))
 1 2)  @result{} 3
@end lisp

This facility is recursive:
@lisp
((lambda ((cons x y) (list z (cons v w)))
   (+ x (+ y (+ z (+ v w)))))
 (cons (cons 1 2) (list 3 (cons 4 5))))  @result{}  15
@end lisp

@noindent
because the procedure picks apart the incoming structure and finds the
numbers inside.  The same destructuring rules apply to bindings
introduced by @code{let} and @code{let*}, but not @code{letrec}.

@lisp
(let (((cons (cons x y) (list z (cons v w)))
       (cons (cons 1 2) (list 3 (cons 4 5)))))
  (+ x (+ y (+ z (+ v w)))))  @result{}  15
@end lisp

In principle, VLAD also destructures constants and closures that may
appear in the formal parameter position of a procedure, but I don't
know whether this is ever useful outside the internals of AD
transforms.
@todo Why does VLAD destructure closures, etc?  What's a @code{variable-access-expression}?

@node Literals
@section Literals

@defvr Literal #t
@defvrx Literal #f
Literal syntax for booleans: like Scheme.
@end defvr

Literal syntax for numbers is also like Scheme, except that all
numerals are interpreted as constant IEEE-64 floating point numbers,
because the only numbers in VLAD are IEEE-64 floating point.

@node Special forms
@section Special forms

VLAD supports the following special forms.  They are like the
corresponding Scheme special forms, except for some differences
pointed out with each one:

@defspec lambda formalspec expression
Like Scheme, except for destructuring the formal parameters given by
@var{formalspec} (@pxref{Destructuring}) and may only have one
@var{expression} in the body.
@end defspec

@defspec define definiendum definiens
Like Scheme, except may only appear at the top level of a program (no
internal defines).  Also, via @code{lambda}, supports destructuring
but does not support multi-expression procedure bodies.  A name may be
redefined only if a non-definition separates its redefinition from its
original definition (otherwise the @code{letrec} that the block of
definitions is turned into has a duplicate variable).  Also,
@var{definiens} must be a @code{lambda} expression, either explicitly or
via the @code{(define (@var{name} @var{formals}@dots{}) @dots{})}
syntax (which is supported).
@end defspec

@defspec let bindings@dots{} expression
@defspecx let* bindings@dots{} expression
@defspecx letrec bindings@dots{} expression
Like Scheme except may only have one @var{expression} in the body.
VLAD does not support the ``named let'' Scheme iteration syntax.
The initialization expressions in the @code{letrec} form must
be @code{lambda} expressions (this is the common case anyway).
@todo Are the destructuring rules different for let, let* and letrec?
@end defspec

@defspec cond clauses@dots{}
Like Scheme, except the final @code{else} clause is required, and
the syntaxes
@code{(cond ... (e) ...)} and @code{(cond ... (e1 => e2) ...)}
are not supported.  Also, clause bodies must be one expression.
@end defspec

@defspec if predicate consequent alternate
Like Scheme; VLAD does not support the one-armed @code{if} syntax.
@end defspec

@defspec quote datum
@defspecx and expressions@dots{}
@defspecx or expressions@dots{}
Like Scheme.  VLAD does not support @code{quasiquote} or @code{unquote}.
@end defspec

@defspec cons car cdr
@defspecx cons* items@dots{}
@defspecx list items@dots{}
These do the same thing as in Scheme, except that they are special
forms in VLAD, and so may not be passed as function parameters,
returned from functions, etc.
@end defspec

@node Procedures
@section Procedures

@defun null? object
@defunx boolean? object
@defunx pair? object
@defunx procedure? object
What you expect.
@end defun

@defun if-procedure predicate consequent-thunk alternate-thunk
Normally, you would use the @code{if} form, but the procedure version
is provided for completeness.  This is convenient to do because in
VLAD, @code{if} is a macro that expands as

@example
(if p c a)  @expansion{}  (if-procedure p (lambda () c) (lambda () a))
@end example

@noindent
and @code{if-procedure} is supplied primitively.  @code{if-procedure}
does what the Scheme procedure

@example
(define (if-procedure p c a)
  (if p (c) (a)))
@end example

@noindent
would do.
@end defun

@node Input and Output
@section Input and Output

VLAD provides two I/O primitives:

@deffn Procedure read-real
Takes no arguments, reads a real number from the standard input, and
returns it.
@end deffn

@deffn Procedure write x
Takes a real number argument, writes it to the standard output, and
returns it.  Since VLAD does not support multiple expressions in
procedure bodies, if you want to write and then do something else,
you should:

@example
(let ((ignore (write foo)))
  do-something-else)
@end example
@end deffn

@noindent
@todo structured WRITE works in the interpreter; what about the compiler?
@todo What is WRITE-REAL supposed to be?

@node Introducing Imprecision
@section Introducing Imprecision

@defun real x
At runtime, @code{real} is the identity function on real numbers.  However,
@code{real} forces the flow analysis to forget the value of its argument, and
avoid specializing any procedures that use it to its exact value.
@xref{Performance}.
@end defun

@noindent
For example, given

@lisp
(define (fact x)
  (if (= x 0)
      1
      (* x (fact (- x 1)))))
@end lisp

@noindent
writing

@lisp
(fact 5)
@end lisp

@noindent
would cause the flow analysis to unroll the recursion in @code{fact}
all the way, and completely solve the return value of that form (to
@code{120}) at compile time.  This could prove prohibitively
expensive.
@todo{There are some internal wideners that prevent this absurd
behavior; how do they work?  Are they good enough that @code{real} is
wizard-only now?}

In contrast, writing

@lisp
(fact (real 5))
@end lisp

@noindent
would cause the flow analysis to produce a @code{fact} procedure that
computes the factorials of (positive integer) real numbers, and
compute the factorial of @code{5} at runtime.

@node Numerics
@chapter Numerics

The numbers in VLAD are all IEEE-64 floating point.  There is no
provision for integer arithmetic except as a subset of floating point
arithmetic, and there is no distinction between exact and inexact
numbers.
Numeric constants are written in the standard way (except the literal
complex number syntax, of course).

The following subset of the Scheme numeric basis is provided as
primitives:

@defun + x y
@defunx - x y
@defunx * x y
@defunx / x y
@defunx sqrt x
@defunx exp x
@defunx log x
@defunx sin x
@defunx cos x
@defunx atan x y
@defunx = x y
@defunx < x y
@defunx > x y
@defunx <= x y
@defunx >= x y
@defunx zero? x
@defunx positive? x
@defunx negative? x
@defunx real? x
Agree with standard Scheme semantics, expect for questions of
arity.  No VLAD primitive takes variable numbers of arguments, so all
of the above are either unary or binary, as indicated.  Notably,
@code{atan} is binary; and no unary minus is provided.
@end defun

@node Forward AD
@chapter Forward AD

The modus operandi for forward AD is:

@enumerate
@item
Bundle the primal input value with a tangent value (representing the
direction of a directional derivative), with
@code{(bundle @var{primal} (perturb @var{tangent}))}.

@item
Transform the function being differentiated to do the right thing with
such bundles, with @code{(j* @var{f})} which is a non-primitive procedure definable
as @code{(define (j* @var{f}) (bundle @var{f} (perturb (zero @var{f}))))}; more on this below.

@item
Push the bundle through the transformed function.

@item
Extract from the output the primal value and the derivative along that
direction with @code{(primal @var{bundle})} and @code{(unperturb (tangent @var{bundle}))}, respectively.
@end enumerate

@noindent
Here are the details of the VLAD procedures that do this:

@defun perturb object
Type-tags the given @var{object} as being a perturbation.  This may be
done with any VLAD object, but it is most useful with real numbers
directly, or structured objects that contain real numbers inside.
@end defun

@defun perturbation? object
Detects whether the given @var{object} is a pertubation constructed with
@code{perturb}.
@end defun

@defun unperturb perturbation
Strips the perturbation tag off the given @var{perturbation} and returns the
underlying object.
@end defun

@defun bundle primal perturbation
Bundles a given @var{primal} value and a given @var{perturbation}
into a primal-tangent bundle.  The primal and the perturbation have to
have the same shape, differing only in the real numbers they contain.
This is useful for constructing inputs to forward-mode functions.
@code{bundle} also operates on functions to transform them to treat
bundles correctly; see below.
@end defun

@defun forward? object
Detects whether the given @var{object} is a bundle constructed with
@code{bundle}.
@end defun

@defun primal bundle
Extracts the primal component of the given @var{bundle}.
@end defun

@defun tangent bundle
Extracts the tangent component of the given @var{bundle}.  You
probably want to call @code{unperturb} on the output of
@code{tangent}.
@end defun

@defun zero object
Constructs an object of the same shape as @var{object}, but with all
real values replaced with zero.
@end defun

@todo{The following description is factually correct, but may send the
wrong message.  The reason I wrote it like this is because I haven't
thought through all the math underlying the reasons why @code{bundle}
behaves the way it does.  In particular, I am not convinced that the
operation @code{bundle} performs on functions is actually the same
operation as what it does to data, and should have the same name.
Nonetheless, this is how the current code works, and of course this is
one of the central features of VLAD so it better be described in the
documentation.}

The @code{bundle} primitive has slightly different behavior on data and on
procedures.  @code{bundle} operating on procedures is so arranged that
the pushforward operator, namely the operator that transforms a primal
function into one that will operate on bundles and compute derivatives
therewith, can be defined as:

@example
(define (j* f)
  (bundle f (perturb (zero f))))
@end example

@noindent
Given such a @code{j*}, one can then write forward-mode
differentiation procedures as follows:

@example
(define (derivative-R->Rn-using-j* f)
  (let ((f-forward (j* f)))
    (lambda (x)
      (unperturb (tangent (f-forward (bundle x (perturb 1))))))))

(define (directional-derivative-using-j* f)
  (let ((f-forward (j* f)))
    (lambda (x dx)
      (unerturb (tangent (f-forward (bundle x (perturb dx))))))))

(define (directional-derivative-via-R->Rn-derivative f)
  (lambda (x dx)
    ((derivative-R->Rn-using-j*
      (lambda (r) (f (+ x (* r dx)))))
     0)))
@end example

@noindent
etc, to taste.

@node Reverse AD
@chapter Reverse AD

The modus operandi for reverse AD is:

@enumerate
@item
Tag the primal inputs as things for which sensitivity values are
desired, with @code{(*j @var{primal})}.

@item
Transform the function being differentiated to collect a record of the
primal computation it does, and to assemble a procedure that can use
that record to compute sensitivity values in reverse, with @code{(*j @var{f})}.

@item
Run the transformed function on the tagged inputs to create that
procedure (and also the primal answer).

@item
Tag a direction in the output space as the initial output sensitivity, with
@code{(sensitize @var{cotangent})}.

@item
Apply the reverse procedure to that tagged direction.

@item
Untag the resulting sensitivity object to extract the corresponding
input change direction, with @code{(cdr (unsensitize @var{result}))}
(more below).
@end enumerate

@noindent
Here are the details of the VLAD procedures that do this:

@defun *j primal
Transforms the given @var{primal} object into reverse-AD form.  In the
case of data, tags it as being the primal value for a reverse AD
computation.  In the case of functions, transforms them to accept such
data and produce reverse procedures.  The resulting transformed
function, when given a tagged input, will produce a pair of the tagged
primal output and the procedure for computing sensitivities in
reverse.  That procedure, when given a sensitivity corresponding to
the output (and of the same shape), will produce a sensitivity-tagged
pair of the procedure for doing the original primal computation and a
sensitivity corresponding to the input.  The type of @code{*j} applied
to a function is:

@example
*j: (-> (-> al be)
        (-> (r-tag al)
            (cons (r-tag be)
                  (-> (sens be)
                      (sens (cons (-> al be) al)))))
@end example

Also see below.

I can only assume that the procedure for doing the primal computation
is echoed this way out of a sense of symmetry, or else for debugging
purposes.
@end defun

@defun *j-inverse reverse-transformed-object
Undoes the transformation done by @code{*j} and returns the original
object.
@end defun

@defun reverse? object
Returns whether the given @var{object} has been transformed by
@code{*j}.
@end defun

@defun sensitize object
Returns a sensitivity-tagged version of the given @var{object}.
@end defun

@defun sensitivity? object
Detects whether the given @var{object} is a sensitivity.
@end defun

@defun unsensitize sensitivity
Strips the sensitivity tag off the given @var{sensitivity} and returns
the underlying object.
@end defun

@defun plus object1 object2
Adds the two given @var{object}s pointwise.  They must have the same
shape.  @code{(plus @var{object} (zero @var{object}))} is an identity
operation.  This is important in the interior of the reverse
computation, because this is the reverse transform of the implicit
fanout of using the same variable more than once.  It is also made
available to the user.
@end defun

@noindent
Given these primitives, one can write procedures for doing
differentiation in reverse mode such as this:

@example
(define (gradient-Rn->R-using-*j f)
  (let ((f-reverse (*j f)))
    (lambda (x)
      (cdr (unsensitize ((cdr (f-reverse (*j x))) (sensitize 1)))))))
@end example

@node Performance
@chapter Performance

@todo Just how thorough is the flow analysis?  How does one control it?

@node Index
@unnumbered Binding Index

@printindex fn
@bye
