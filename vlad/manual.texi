\input texinfo @c -*-texinfo-*-
@comment %**start of header
@setfilename manual
@settitle VLAD Programmer Manual
@comment %**end of header

@allowcodebreaks false
@setchapternewpage off
@macro todo{text}
@strong{TODO: \text\}
@end macro

@contents

@ifnottex
@node Top
@top VLAD Programmer Manual

@end ifnottex

@menu
* Overview::
* Getting Started::
* Scheme Stuff::
* Numeric Basis::
* Input and Output::
* Introducing Imprecision::
* Forward AD::
* Reverse AD::
@end menu

@node Overview
@chapter Overview

VLAD is a functional language with a first-class automatic
differentiation operator and an aggressively optimizing compiler.  The
purpose of VLAD is to push the envelope on the speed of numeric
computing, without sacrificing any essential expressive power; and to
dispel any myths that automatic differentiation needs to be hard to
use or slow to execute.

VLAD is essentially a subset of Scheme, augmented with functions for
doing automatic differentiation, and implemented with a compiler that
does very aggressive optimizations.  In particular, VLAD shares
Scheme's simple syntax and overall execution model.  The most striking
differences are the automatic differentiation, destructuring of
procedure arguments, and how fast programs go once you've compiled
them.  VLAD is designed to compile to efficient code without
sacrificing any essential expressive power.  Being a research
prototype, however, VLAD sacrifices various uninteresting
conveniences, which are left to user-space libraries and to later
incarnations of these language design ideas.

@node Getting Started
@chapter Getting Started

A VLAD program is notionally just a single expression.  For example,

@lisp
(+ 3 4)
@end lisp
@noindent
is a perfectly good VLAD program whose result is @code{7}.  The
Stalingrad program reads a file containing a VLAD expression, compiles
that expression, evaluates it, and prints the result.

As a syntactic convenience, helper procedures can be defined using
@code{define}.  Also, Stalingrad will treat multiple non-definition
expressions in a single source file as multiple ``programs'', and
compile and execute all of them in turn.  The scope of definitions
introduced with define is the entire contiguous block of definitions
in which that define appears, and all subsequent expressions.

For example,

@lisp
(define (double-loop)
  (let* ((x (read-real))
         (y (write (* 3 x))))
    (double-loop)))

(double-loop)
@end lisp
@noindent
is a VLAD program that will read real numbers from standrad input
write their triples to standard output.

VLAD has the following support for multifile programs: If you have a
file of definitions named @var{filename}, you can use those
definitions in another program by writing @code{(include
"@var{filename}")} as a toplevel form in that program.  This mechanism
works recursively.

You can use Stalingrad to compile but not run a VLAD program by
passing it the @code{--compile} option.  If the program was in file
@file{foo.vlad}, Stalingrad will emit the binary into the file
@file{foo}, which you can then execute.  Stalingrad also has many other
options and modes for controlling the compilation process, emitting
various partial results thereof, etc.

@node Scheme Stuff
@chapter Scheme Stuff

The basic structure of VLAD code is inherited from Scheme.
Identifiers are whitespace-delimited.  Expressions are written in
fully-parenthesized prefix notation.  Comments begin with a semicolon
character (@code{;}) and last until the end of the line.  
@todo Does VLAD support expression comments with #; and/or block comments with #| |#?
Variables are lexically scoped.  Objects have unlimited extent.

The basic evaluation model of VLAD is also inherited from Scheme.  The
first subexpression of an expression determines how that expression
will be evaluated---if it's an identifier naming a special form,
then the whole form will be evaluated that way; otherwise, the first
subform will be evaluated, treated as a procedure, and applied to the
evaluated values of the remaining subforms.

The main difference between Scheme and VLAD at this level is that VLAD
has automatic destructuring of bound values.  That is, if the procedure
made by
@example
(lambda (cons x y) ...)
@end example
@noindent
is passed a pair, then in the body of this procedure @code{x} and
@code{y} will be bound to the car and cdr of that pair, respectively.
Dually, when a procedure is passed syntactically multiple arguments,
as with passing the procedure @code{foo} the three arguments
@code{bar}, @code{baz}, and @code{quux},

@example
(foo bar baz quux)
@end example
@noindent
the three arguments are implicitly collected into a structure with
@code{cons*} and passed to the procedure as a single argument.
Presumably, the procedure will destructure that structure to get the
pieces; for example, if @code{foo} were defined with
@example
(lambda (bar baz quux) ...)
@end example
@noindent
that actually represents a destructuring operation.  All this notional
structuring and destructuring is dealt with at compile time (see
"Performance Model") and incurs no runtime overhead.  See
"Destructuring" for the detailed rules.

@todo Detailed lexical syntax of VLAD, differences from Scheme

@todo Destructuring

@todo Performance Model

@menu
* Literals::
* Special forms::
* Procedures::
@end menu

@node Literals
@section Literals

@defvr Literal #t
@defvrx Literal #f
Literal syntax for booleans: like Scheme.
@end defvr

Literal syntax for numbers is also like Scheme, except that all
numerals are interpreted as constant IEEE-64 floating point numbers,
because the only numbers in VLAD are IEEE-64 floating point.

@todo () ?

@node Special forms
@section Special forms

VLAD supports the following special forms.  They are like the
corresponding Scheme special forms, except for some differences
pointed out with each one:

@defspec lambda formalspec expression
Like Scheme, except for destructuring the formal parameters given by
@var{formalspec} (see "Destructuring") and may only have one
@var{expression} in the body.
@end defspec

@defspec define definiendum definiens
Like Scheme, except may only appear at the top level of a program (no
internal defines).  Also, via @code{lambda}, supports destructuring
but does not support multi-expression procedure bodies.
@todo{Are redefinitions of names already defined in the same
define-block acceptable?}
@end defspec

@defspec let bindings@dots{} expression
@defspecx let* bindings@dots{} expression
@defspecx letrec bindings@dots{} expression
Like Scheme except may only have one @var{expression} in the body.
VLAD does not support the ``named let'' Scheme iteration syntax.
@todo Are the destructuring rules different for let, let* and letrec?
@todo Can the initialization forms in letrec not be lambdas?
@end defspec

@defspec cond clauses@dots{}
Like Scheme, except the final @code{else} clause is required, and
the syntaxes
@code{(cond ... (e) ...)} and @code{(cond ... (e1 => e2) ...)}
are not supported.  Also, clause bodies must be one expression.
@end defspec

@defspec if predicate consequent alternate
Like Scheme; VLAD does not support the one-armed @code{if} syntax.
@end defspec

@defspec quote datum
@defspecx and expressions@dots{}
@defspecx or expressions@dots{}
Like Scheme.
@end defspec

TODO quasiquote and unquote?

@defspec cons car cdr
@defspecx cons* items@dots{}
@defspecx list items@dots{}
These do the same thing as in Scheme, except that they are special
forms in VLAD, and so may not be passed as function parameters,
returned from functions, etc.
@end defspec

@node Procedures
@section Procedures

@defun null? thing
@defunx boolean? thing
@defunx pair? thing
@defunx procedure? thing
Do what you expect.
@end defun

@defun if-procedure predicate consequent-thunk alternate-thunk
Normally, you would use the @code{if} form, but the procedure version
is provided for completeness.  This is convenient to do because in
VLAD, @code{if} is a macro that expands as
@example
(if p c a)  ==>  (if-procedure p (lambda () c) (lambda () a))
@end example
@noindent
and @code{if-procedure} is supplied primitively.  @code{if-procedure}
does what the Scheme procedure
@example
(define (if-procedure p c a)
  (if p (c) (a)))
@end example
@noindent
would do.
@end defun

@node Numeric Basis
@chapter Numeric Basis

The numbers in VLAD are all IEEE-64 floating point.  There is no
provision for integer arithmetic except as a subset of floating point
arithmetic, and there is no distinction between exact and inexact
numbers.
Numeric constants are written in the standard way.
@todo Does VLAD support radix prefixes?

The following subset of the Scheme numeric basis is provided as
primitives:

@defun + x y
@defunx - x y
@defunx * x y
@defunx / x y
@defunx sqrt x
@defunx exp x
@defunx log x
@defunx sin x
@defunx cos x
@defunx atan x y
@defunx = x y
@defunx < x y
@defunx > x y
@defunx <= x y
@defunx >= x y
@defunx zero? x
@defunx positive? x
@defunx negative? x
@defunx real? x
Agree with standard Scheme semantics, expect for questions of
arity.  No VLAD primitive takes variable numbers of arguments, so all
of the above are either unary or binary, as indicated.  Notably,
@code{atan} is binary; and no unary minus is provided.
@end defun

@node Introducing Imprecision
@chapter Introducing Imprecision

@defun real
At runtime, @code{real} is the identity function on real numbers.  However,
@code{real} forces the flow analysis to forget the value of its argument, and
avoid specializing any procedures that use it to its exact value.  See
"Performance Model".
@end defun

@noindent
For example, given
@lisp
(define (fact x)
  (if (= x 0)
      1
      (* x (fact (- x 1)))))
@end lisp
@noindent
writing
@lisp
(fact 5)
@end lisp
@noindent
would cause the flow analysis to unroll the recursion in @code{fact}
all the way, and completely solve the return value of that form (to
@code{120}) at compile time.  This could prove prohibitively
expensive.
@todo{There are some internal wideners that prevent this absurd
behavior; how do they work?  Are they good enough that @code{real} is
wizard-only now?}

In contrast, writing
@lisp
(fact (real 5))
@end lisp
@noindent
would cause the flow analysis to produce a @code{fact} procedure that
computes the factorials of (positive integer) real numbers, and
compute the factorial of @code{5} at runtime.

@node Input and Output
@chapter Input and Output

VLAD provides two I/O primitives:

@deffn Procedure read-real
Takes no arguments, reads a real number from the standard input, and
returns it.
@end deffn

@deffn Procedure write x
Takes a real number argument, writes it to the standard output, and
returns it.  Since VLAD does not support multiple expressions in
procedure bodies, if you want to write and then do something else,
you should:
@example
(let ((ignore (write foo)))
  do-something-else)
@end example
@end deffn
@noindent
@todo structured WRITE ? What is WRITE-REAL supposed to be?

@node Forward AD
@chapter Forward AD

The modus operandi for forward AD is:
@enumerate
@item
Bundle the primal input value with a tangent value (representing the
direction of a directional derivative), with
@code{(bundle @var{primal} (perturb @var{tangent}))}.

@item
Transform the function being differentiated to do the right thing with
such bundles, with @code{(j* @var{f})} which is a non-primitive procedure definable
as @code{(define (j* @var{f}) (bundle @var{f} (perturb (zero @var{f}))))}; more on this below.

@item
Push the bundle through the transformed function.

@item 
Extract from the output the primal value and the derivative along that
direction with @code{(primal @var{bundle})} and @code{(unperturb (tangent @var{bundle}))}, respectively.
@end enumerate
@noindent
Here are the details of the VLAD procedures that do this:

@defun perturb object
Type-tags the given @var{object} as being a perturbation.  This may be
done with any VLAD object, but it is most useful with real numbers
directly, or structured objects that contain real numbers inside.
@end defun

@defun perturbation? object
Detects whether the given @var{object} is a pertubation constructed with
@code{perturb}.
@end defun

@defun unperturb perturbation
Strips the perturbation tag off the given @var{perturbation} and returns the
underlying object.
@end defun

@defun bundle primal perturbation
Bundles a given @var{primal} value and a given @var{perturbation}
into a primal-tangent bundle.  The primal and the perturbation have to
have the same shape, differing only in the real numbers they contain.
This is useful for constructing inputs to forward-mode functions.
@code{bundle} also operates on functions to transform them to treat
bundles correctly; see below.
@end defun

@defun forward? object
Detects whether the given @var{object} is a bundle constructed with
@code{bundle}.
@end defun

@defun primal bundle
Extracts the primal component of the given @var{bundle}.
@end defun

@defun tangent bundle
Extracts the tangent component of the given @var{bundle}.  You
probably want to call @code{unperturb} on the output of
@code{tangent}.
@end defun

@defun zero object
Constructs an object of the same shape as @var{object}, but with all
real values replaced with zero.
@end defun

@todo{The following description is factually correct, but may send the
wrong message.  The reason I wrote it like this is because I haven't
thought through all the math underlying the reasons why @code{bundle}
behaves the way it does.  In particular, I am not convinced that the
operation @code{bundle} performs on functions is actually the same
operation as what it does to data, and should have the same name.
Nonetheless, this is how the current code works, and of course this is
one of the central features of VLAD so it better be described in the
documentation.}

@code{bundle} has slightly different behavior on data and on
procedures.  @code{bundle} operating on procedures is so arranged that
the pushforward operator, namely the operator that transforms a primal
function into one that will operate on bundles and compute derivatives
therewith, can be defined as:
@example
(define (j* f)
  (bundle f (perturb (zero f))))
@end example
@noindent
Given such a @code{j*}, one can then write forward-mode
differentiation procedures as follows:
@example
(define (derivative-R->Rn-using-j* f)
  (let ((f-forward (j* f)))
    (lambda (x)
      (unperturb (tangent (f-forward (bundle x (perturb 1))))))))

(define (directional-derivative-using-j* f)
  (let ((f-forward (j* f)))
    (lambda (x dx)
      (unerturb (tangent (f-forward (bundle x (perturb dx))))))))

(define (directional-derivative-via-R->Rn-derivative f)
  (lambda (x dx)
    ((derivative-R->Rn-using-j*
      (lambda (r) (f (+ x (* r dx)))))
     0)))
@end example
@noindent
etc, to taste.

@node Reverse AD
@chapter Reverse AD

The modus operandi for reverse AD is:
@enumerate
@item
Tag the primal inputs as things for which sensitivity values are
desired, with @code{(*j @var{primal})}.

@item
Transform the function being differentiated to collect a record of the
primal computation it does, and to assemble a procedure that can use
that record to compute sensitivity values in reverse, with @code{(*j @var{f})}.

@item
Run the transformed function on the tagged inputs to create that
procedure (and also the primal answer).

@item
Tag a direction in the output space as the initial output sensitivity, with
@code{(sensitize @var{cotangent})}.

@item
Apply the reverse procedure to that tagged direction.

@item
Untag the resulting sensitivity object to extract the corresponding
input change direction, with @code{(cdr (unsensitize @var{result}))}
(more below).
@end enumerate
@noindent
Here are the details of the VLAD procedures that do this:

@defun *j primal
Transforms the given @var{primal} object into reverse-AD form.  In the
case of data, tags it as being the primal value for a reverse AD
computation.  In the case of functions, transforms them to accept such
data and produce reverse procedures.  The resulting transformed
function, when given a tagged input, will produce a pair of the tagged
primal output and the procedure for computing sensitivities in
reverse.  That procedure, when given a sensitivity corresponding to
the output (and of the same shape), will produce a sensitivity-tagged
pair of the procedure for doing the original primal computation and a
sensitivity corresponding to the input.  The type of @code{*j} applied
to a function is:

@example
*j: (-> (-> al be)
        (-> (r-tag al)
            (cons (r-tag be)
                  (-> (sens be)
                      (sens (cons (-> al be) al)))))
@end example

Also see below.

I can only assume that the procedure for doing the primal computation
is echoed this way out of a sense of symmetry, or else for debugging
purposes.
@end defun

@defun *j-inverse reverse-transformed-object
Undoes the transformation done by @code{*j} and returns the original
object.
@end defun

@defun reverse? object
Returns whether the given @var{object} has been transformed by
@code{*j}.
@end defun

@defun sensitize object
Returns a sensitivity-tagged version of the given @var{object}.
@end defun

@defun sensitivity? object
Detects whether the given @var{object} is a sensitivity.
@end defun

@defun unsensitize sensitivity
Strips the sensitivity tag off the given @var{sensitivity} and returns
the underlying object.
@end defun

@defun plus object1 object2
Adds the two given @var{object}s pointwise.  They must have the same
shape.  @code{(plus @var{object} (zero @var{object}))} is an identity
operation.  This is important in the interior of the reverse
computation, because this is the reverse transform of the implicit
fanout of using the same variable more than once.  It is also made
available to the user.
@end defun

@noindent
Given these primitives, one can write procedures for doing
differentiation in reverse mode such as this:
@example
(define (gradient-Rn->R-using-*j f)
  (let ((f-reverse (*j f)))
    (lambda (x)
      (cdr (unsensitize ((cdr (f-reverse (*j x))) (sensitize 1)))))))
@end example
@bye
