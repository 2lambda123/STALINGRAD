(+ 1 2)
(- 1 2)
; (- 1)
(* 1 2)
(/ 1 2)
(sqrt 2)
(exp 1)
(= 1 1)
(< 1 2)
(zero? 4)
(zero? 0)
(positive? -1)
(positive? 1)
(negative? 2)
(negative? -1)
(sin 3)
(cos 3)
(log 2)
(atan 2 3)
(real? 4)
(real? 2.073e-2)


(define (abs x) (if (negative? x) (- 0 x) x))
(abs -3)

;; (define (double-loop)
;;   (let ((x (read-real)))
;;     (let ((y (write (* 2 x))))
;;       (double-loop))))

;; (double-loop)

(let ((ignore (write (* 2 (real 3)))))
  3)


(define (fact x)
  (if (= x 0)
      1
      (* x (fact (- x 1)))))

(fact 5)
(fact (real 5))

(perturb 1)
(write (perturb 1))
(perturbation? (perturb 1))
(perturbation? 1)
(bundle 1 (perturb 1))
(forward? (bundle 1 (perturb 1)))
(forward? 1)
(forward? (perturb 1))
(unperturb (perturb 1))
(primal (bundle 1 (perturb 1)))
(tangent (bundle 1 (perturb 1)))
(perturb (cons 1 2))
(perturb #t)
(bundle (cons 1 2) (perturb (cons 3 4)))
(*j 1)

((*j sin) (*j 1))
(define (car (cons x y)) x)
(define (cdr (cons x y)) y)
(reverse? (car ((*j sin) (*j 1))))
(procedure? (cdr ((*j sin) (*j 1))))
((cdr ((*j sin) (*j 1))) (sensitize 1))
(reverse? (*j sin))
(plus (cons 1 2) (cons 2 3))
